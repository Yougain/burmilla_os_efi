error="\033[41m\033[33mERROR    :\033[m \033[31m"
warning="\033[43m\033[31mWARNING:\033[m \033[33m"
info="\033[46m\033[34mINFO     :\033[m \033[36m "
plain="\033[m"
normal="\033[m"

black="0"
red="1"
green="2"
yellow="3"
blue="4"
purple="5"
magenta="5"
cyan="6"
white="7"


allColors="black red green yellow blue purple magenta cyan white"

function capitalize(){
	local B
	local F
	B=`echo -n "${1:0:1}" | tr "[:lower:]" "[:upper:]"`
	F="${B}${1:1}"
	shift
	echo -n $F $@
}

function errmsg(){
	if [ -z "$ERRMSG" ]; then
		ERRMSG="$error`capitalize $@`$plain"
	else
		ERRMSG="$ERRMSG
$error""`capitalize $@`"$plain
	fi
}


alias err=errmsg
alias error=errmsg


function info_n(){
	echo -ne $info`capitalize $@`$plain
}
function info(){
	info_n $@"\n"
}


function warning_n(){
	echo -ne "$warning""$@"
}
function warning(){
	warning_n "$@""\n"
}

function warn(){
	warning_n "$@""\n"
}
alias warn_n=warning_n


for col in `echo $allColors`; do
	eval '
		'`capitalize $col`'="\033[3$'$col'""m"
		'_`capitalize $col`'="\\033[3$'$col'""m"
		function '$col'_n(){
			echo -ne "\033[3$'$col'""m''$@''$plain"
		}
		function '$col'(){
			'$col'_n $@"\n"
		}
		function bg'`capitalize $col`'_n(){
			echo -ne "\033[4$'$col'""m''$@''$plain"
		}
		function bg'`capitalize $col`'(){
			bg'`capitalize $col`'_n $@"\n"
		}
	'
	for bgCol in $allColors; do
		eval '
			function '$col'Bg'`capitalize $bgCol`'_n(){
				echo -ne "\033[3$'$col'""m\033[4$'$bgCol'""m''$@''$plain"
			}
			function '$col'Bg'`capitalize $bgCol`'(){
				'$col'Bg'`capitalize $bgCol`'_n $@
			}
		'
	done
done


function exit_if_err(){
	if [ -n "$1" ]; then
		errmsg $@
	fi
	if [ -n "$ERRMSG" ];then
		echo -en $ERRMSG
		exit 1
	fi
}

function die(){
	if [ -n "$1" ]; then
		errmsg $@
	fi
	if [ -n "$ERRMSG" ];then
		echo -en $ERRMSG
	fi
	exit 1
}


function ssh_param(){
	local p
	local h
	local port
	local host
	local opt_start
	while (( "$#" )); do
		if [ "${1:0:1}" = "-" -o "$opt_start" = 1 ];then
			opt_start=1
			SSH_OPTS="$@"
			break
		else
			h="${1%%:*}"
			p="${1##*:}"
			if [ "$h" = "$1" ];then # ':' is missing
				if [ -n "`echo -n $1|egrep -o '^[0-9][0-9]*$'`" ];then
					if [ -n "$port"];then
						die "duplicated port"
					else
						port=$p
					fi
				else
					if [ -n "$host"];then
						die "duplicated host name"
					else
						port=$p
					fi
				fi
			else
				if [ -n "$port"];then
					die "duplicated port"
				else
					port=$p
				fi
				if [ -n "$host"];then
					die "duplicated host name"
				else
					host=$h
				fi
			fi
		fi
		shift
	done
	local o
	local on
	for o in $SSH_OPTS;do
		if [ "$o" = "-l" ]; then
			on=1
		else
			if [ -n "$on" ]; then
				SSH_USER=$o
				break
			fi
		fi
	done
	if [ -z "$SSH_USER" ];then
		SSH_USER=$USER
		if [ -z "$SSH_USER" ];then
			die "cannot find \$USER"
		fi
	fi
	if [ -n "$port" ];then
		port=" -p $port"
	fi
	ssh $port -v -o "ConnectTimeout=5"  -o "PasswordAuthentication no" -o "StrictHostKeyChecking no" -o "UserKnownHostsFile /dev/null" $SSH_OPTS $host echo -n > /tmp/test_ssh 2>&1
	if [ "$?" = "0" ];then
		local SSH_CON_LINE=`egrep -o 'debug1: Connecting to .* port [0-9]+' /tmp/test_ssh`
		SSH_PORT=`echo $SSH_CON_LINE| egrep -o '[0-9]+$'`
		SSH_PORT_OPT=" -p $SSH_PORT"
		SSH_HOST_IP=`echo $SSH_CON_LINE| egrep -o '\[[0-9/A-Fa-f\.:]+\]'| egrep -o [0-9/A-Fa-f\.:]+`
		SSH_HOST=$1
		if [ -n "$SSH_PORT" ];then
			return 0
		fi
	fi
	return 1
}


function wait_sshd_start(){
	if [ -z "$SSH_PORT" -o -z "$SSH_HOST" ];then
		die "missing ssh paramter variables. Please execute 'ssh_param SERVER_NAME' first."
	fi
	local SSH_CON_
	info_n connecting SSH...
	for i in $(seq 1 120); do
		sleep 1
		blue_n "."
		SSH_CON_=`echo | nc $SSH_HOST_IP $SSH_PORT 2>&1`
		if [ "${SSH_CON_:0:3}" = "SSH" ];then
			cyanBgBlue connected
			return
		fi
	done
	echo
	die Tried 120 times. Still cannot connect SSH port "($SSH_PORT)". Exited.
}


THIS_FILE="$(realpath -s "$0")"


function transfer_arguments(){
	local i
	local j=-1
	while IFS= read -r -d $'\0' i; do
	    if [ $j != "-1" ];then
	    	TRANSFER_ARGUMENTS="$TRANSFER_ARGUMENTS$1$j='$i'"$'\n'
	    fi
	    j=$(( j + 1 ))
	done < <(cat /proc/$$/cmdline)
}

transfer_arguments A

SCRIPT_ID=`rand 100000000`


function col_width(){
	if [ -z "$TAB_STOP" ];then
		TAB_STOP=4
	fi
	local i=0
	local len=${#1}
	local pos=0
	while [ $i -lt $len ];do
		case "${1:$i:1}" in
			"	")
				pos=$((pos + TAB_STOP - pos % TAB_STOP))
				;;
			*)
				pos=$((pos + 1))
				;;
		esac
		i=$((i + 1))
	done
	echo $pos
}

function putsp(){
	if [ -z "$TAB_STOP" ];then
		TAB_STOP=4
	fi
	local w=$1
	local t=$((w / TAB_STOP))
	local s=$((w % TAB_STOP))
	local i
	for ((i = 0; i < t; i++)); do
		echo -n "\t"
	done
	for ((i = 0; i < t; i++)); do
		echo -n " "
	done
}

function trim_indent(){
	if [ -z "$TAB_STOP" ];then
		TAB_STOP=4
	fi
	if [ "$#" = 0 ];then
		local fc
		local ln
		local sp
		PIFS="$IFS"
		IFS=""
		while read ln; do
			lnx="$ln"
			sp=${lnx%%[![:space:]]*}
			if [ -z "$fc" ];then
				res="${ln#$sp}"
				if [ -n "$res" -a "${res:0:1}" != "#" ];then
					fc=`col_width "$sp"`
					echo "$res"
				else
					echo "$ln"
				fi
			else
				trim_indent "$ln" "$fc"
			fi
		done
		IFS="$PIFS"
	else
		local pos=0
		local i=0
		local len=${#1}
		while [ $i -lt $len ];do
			case "${1:$i:1}" in
				"	")
					pos=$((pos + TAB_STOP - pos % TAB_STOP))
					;;
				" ")
					pos=$((pos + 1))
					;;
				*)
					echo ${1:$i}
					break
					;;
			esac
			if [ $pos -ge $fc ];then
				putsp $((pos - fc))
				echo ${1:$i + 1}
				break
			fi
			i=$((i + 1))
		done 
	fi
}


function ssh_do(){
	local sudoing
	if [ "$1" = "sudo" ];then
		sudoing=sudo
		shift
	fi
	if [ -z "$SSH_PORT" -o -z "$SSH_HOST" ];then
		die "missing ssh paramter variables. Please execute 'ssh_param SERVER_NAME' first."
	fi
	if [ "$#" = "0" ];then
		local set_env_lines="set | awk '!/^(BASHOPTS|BASH_VERSINFO|EUID|PPID|SHELLOPTS|UID)=/ {print \$0}'"
		(
			# preserve host environment
			echo "$set_env_lines > /tmp/err.$SCRIPT_ID";
			echo "
				# set client environment
				if [ ! -e /tmp/err.cont.$SCRIPT_ID ];then # missing previous host environment 
					# set client command line argument
					$TRANSFER_ARGUMENTS
					`$set_env_lines`
				else # found previous host environment 
					source /tmp/err.cont.$SCRIPT_ID; 
					rm /tmp/err.cont.$SCRIPT_ID;
				fi
			";
			# restore host environment
			echo "source /tmp/err.$SCRIPT_ID; rm /tmp/err.$SCRIPT_ID";
			# execute script from standard input
			trim_indent
			# preserve environment after script execution
			echo "$set_env_lines > /tmp/err.cont.$SCRIPT_ID;exit 0"
		) | ssh $SSH_PORT_OPT $SSH_OPTS $SSH_HOST $sudoing bash
		if [ "$?" = "1" ];then
			exit 1
		fi
	else
		ssh $SSH_PORT_OPT $SSH_OPTS $SSH_HOST $sudoing $@
	fi
}

function ssh_sudo(){
	ssh_do sudo $@
}


function install_ssh_key(){
	if [ -z "$KEY" ];then
		KEY=`cat ~/.ssh/id_ed25519.pub 2>/dev/null`
		if [ -z "$KEY" ];then
			die Cannot find public key in ~/.ssh/id_ed25519.pub.
		fi
	fi
	if [ -z "$SSH_PROMPT" ];then
		SSH_PROMT="$ "
	fi
	local SET_KEY_CNT=0
	while ! ssh_do echo -n; do
		if [ "$SET_KEY_CNT" = "5" ]; then
			return 1
		fi
		expect -c "
		set timeout 1
		spawn ssh $SSH_PORT_OPT -o \"PasswordAuthentication yes\"  -o \"StrictHostKeyChecking no\" -o \"UserKnownHostsFile /dev/null\" $SSH_OPTS $SSH_HOST
		expect \"assword:\"
		send \"$SSH_USER\n\"
		expect \"$SSH_PROMPT\"
		send \"mkdir ~/.ssh\n\"
		expect \"$SSH_PROMPT\"
		send \"chmod 700 ~/.ssh\n\"
		expect \"$SSH_PROMPT\"
		send \"echo $KEY >> ~/.ssh/authorized_keys\n\"
		expect \"$SSH_PROMPT\"
		send \"exit\"
		"
		sleep 1
		SET_KEY_CNT=$(( SET_KEY_CNT + 1 ))
	done
	return 0
}


function ask_yes_no {
	local ANS
	while true; do
		read ANS
		case $ANS in
			[Yy]*)
				return 0
				;;  
			[Nn]*)
				return 1
				;;
			*)
				;;
		esac
	done
}


function ssh_reboot(){
	ssh_sudo <<'END'
		efi_dev=$(readlink -f /dev/disk/by-uuid/`cat /proc/cmdline|egrep -o "efi=UUID=[0-9a-fA-F-]+"|egrep -o "[0-9a-fA-F-]+$"`|awk 'match($1,/[0-9]+$/){print substr($1,0,length($1)-RLENGTH);}'|awk 'match($1,/^\/dev\//){print substr($1,6,length($1)-5);}')2
		if [ -z "$efi_dev" ]; then die "boot efi device not found."; fi
		mkdir -p /tmp/efi_dev
		mount /dev/$efi_dev /tmp/efi_dev
		touch /tmp/efi_dev/.reboot
		reboot
END
	wait_sshd_start
	echo try ssh connect
	ssh_sudo <<'END'
		efi_dev=$(readlink -f /dev/disk/by-uuid/`cat /proc/cmdline|egrep -o "efi=UUID=[0-9a-fA-F-]+"|egrep -o "[0-9a-fA-F-]+$"`|awk 'match($1,/[0-9]+$/){print substr($1,0,length($1)-RLENGTH);}'|awk 'match($1,/^\/dev\//){print substr($1,6,length($1)-5);}')2
		if [ -z "$efi_dev" ]; then die "boot efi device not found."; fi
		mkdir -p /tmp/efi_dev
		mount /dev/$efi_dev /tmp/efi_dev
		rm /tmp/efi_dev/.reboot
		umount /tmp/efi_dev
		rm -rf /tmp/efi_dev
END
}


function write_env_file(){
	local ln
	local first=0
	local envreg
	envreg=`env_defined | while read ln; do
		if [ "$first" = 0 ];then
			echo -n $ln
			first=1
		else
			echo -n '|'$ln
		fi
	done;`
	local c=$(
		echo -n "'"
		trim_indent | sed 's/'"'"'/'"'"'"'"'"'"'"'"'/g' | sed -r 's/(^|[^\\])\$('$envreg')([^A-Za-z0-9_]|$)/\1'"'"'$\2'"'"'\3/g'
		echo -n "'"
	)
	eval echo "$c" > $1
}


function write_file(){
	local mod
	if [[ $1 =~ ^0[0-9][0-9][0-9]$ ]];then
		mod = $1
		shift
	fi
	local lns="`trim_indent`"
	while (($#));do
		echo $lns > $1
		if [ -n "$mod" ];then
			chmod $mod $1
		fi
		shift
	done
}


function write_grub_script(){
	(set_env ; trim_indent) > $1
}


function write_script(){
	local mod
	if [[ $1 =~ ^0[0-9][0-9][0-9]$ ]]; then
		mod = $1
		shift
	fi
	local first
	local ln
	local lns=$(trim_indent | while read ln;do
		echo $ln
		if [ -z "$first" ];then
			set_env
			first=1
		fi
	done)
	while (($#));do
		echo $lns > $1
		if [ -n "$mod" ];then
			chmod $mod $1
		fi
		shift
	done
}


function env_var(){
	local ln
	declare -p |egrep '^declare -[A-Za-z-]* [A-Za-z_][A-Za-z0-9_]*'| while read ln; do
		ln=${ln#declare -* }
		ln=${ln%%=*}
		tmp="`declare -p $ln 2>/dev/null`"
		if [ "$?" = "0" ];then
			echo $ln
		fi
	done|sort|uniq
}


__ORG_EVAR__="`env_var`"


function get_exported(){
	local ln
	awk 'BEGIN{for (i in ENVIRON) {print i}}' | while read ln; do
		if [ "$ln" != "AWKPATH" ];then
			echo $ln
		fi
	done
}


function env_defined(){
	echo "`env_var`
__ORG_EVAR__
$__ORG_EVAR__" | sort | uniq -u; get_exported | sort | uniq
}

function set_env(){
	local ln
	env_defined | while read ln; do
		ln="`declare -p $ln`"
		ln=${ln#declare -* }
		if [[ ${ln} =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]];then
			echo "$ln=''"
		else
			echo "$ln"
		fi
	done
}



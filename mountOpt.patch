diff -Naur '--exclude=.git' os.prev/config/types.go os.new/config/types.go
--- os.prev/config/types.go	2024-02-15 15:45:46.750000000 +0900
+++ os.new/config/types.go	2024-02-20 16:23:46.720416200 +0900
@@ -210,6 +210,7 @@
 type StateConfig struct {
 	Directory  string   `yaml:"directory,omitempty"`
 	FsType     string   `yaml:"fstype,omitempty"`
+	MountOpt     string   `yaml:"mountopt,omitempty"`
 	Dev        string   `yaml:"dev,omitempty"`
 	Wait       bool     `yaml:"wait,omitempty"`
 	Required   bool     `yaml:"required,omitempty"`
@@ -220,8 +221,10 @@
 	Rngd       bool     `yaml:"rngd,omitempty"`
 	Script     string   `yaml:"script,omitempty"`
 	OemFsType  string   `yaml:"oem_fstype,omitempty"`
+	OemMountOpt  string   `yaml:"oem_mountopt,omitempty"`
 	OemDev     string   `yaml:"oem_dev,omitempty"`
 	BootFsType string   `yaml:"boot_fstype,omitempty"`
+	BootMountOpt string   `yaml:"boot_mountopt,omitempty"`
 	BootDev    string   `yaml:"boot_dev,omitempty"`
 }
 
diff -Naur '--exclude=.git' os.prev/pkg/init/configfiles/configfiles.go os.new/pkg/init/configfiles/configfiles.go
--- os.prev/pkg/init/configfiles/configfiles.go	2024-02-15 15:45:46.760000000 +0900
+++ os.new/pkg/init/configfiles/configfiles.go	2024-02-21 14:40:15.265314500 +0900
@@ -55,6 +55,7 @@
 			ConfigFiles[name] = content
 		}
 	}
+	log.UntilLogWritable("/var/log/boot/init.log")
 	return cfg, nil
 }
 
diff -Naur '--exclude=.git' os.prev/pkg/init/fsmount/fsmount.go os.new/pkg/init/fsmount/fsmount.go
--- os.prev/pkg/init/fsmount/fsmount.go	2024-02-15 15:45:46.760000000 +0900
+++ os.new/pkg/init/fsmount/fsmount.go	2024-02-20 21:31:15.340416200 +0900
@@ -4,6 +4,8 @@
 	"fmt"
 	"strings"
 	"syscall"
+	"os"
+	"os/exec"
 
 	"github.com/burmilla/os/config"
 	"github.com/burmilla/os/config/cmdline"
@@ -22,7 +24,7 @@
 )
 
 func MountOem(cfg *config.CloudConfig) (*config.CloudConfig, error) {
-	if err := mountConfigured("oem", cfg.Rancher.State.OemDev, cfg.Rancher.State.OemFsType, config.OemDir); err != nil {
+	if err := mountConfigured("oem", cfg.Rancher.State.OemDev, cfg.Rancher.State.OemFsType, config.OemDir, cfg.Rancher.State.OemMountOpt); err != nil {
 		log.Debugf("Not mounting OEM: %v", err)
 	} else {
 		log.Infof("Mounted OEM: %s", cfg.Rancher.State.OemDev)
@@ -45,7 +47,7 @@
 		}
 	}
 
-	if err := mountConfigured("boot", cfg.Rancher.State.BootDev, cfg.Rancher.State.BootFsType, config.BootDir); err != nil {
+	if err := mountConfigured("boot", cfg.Rancher.State.BootDev, cfg.Rancher.State.BootFsType, config.BootDir, cfg.Rancher.State.BootMountOpt); err != nil {
 		log.Debugf("Not mounting BOOT: %v", err)
 	} else {
 		log.Infof("Mounted BOOT: %s", cfg.Rancher.State.BootDev)
@@ -54,32 +56,48 @@
 	return cfg, nil
 }
 
-func mountConfigured(display, dev, fsType, target string) error {
-	var err error
+func mountConfigured(display, dname, fsType, target, option string) error {
 
-	if dev == "" {
+
+	if dname == "" {
 		return nil
 	}
 
-	dev = util.ResolveDevice(dev)
-	if dev == "" {
-		return fmt.Errorf("Could not resolve device %q", dev)
-	}
-	if fsType == "auto" {
-		fsType, err = util.GetFsType(dev)
-	}
+	log.Infof("Mounting %s device %s to %s (option = '%s')", display, dname, target, option)
+
+	if _, err := os.Stat("/usr/bin/do_mount"); err == nil {
+		cmd := exec.Command("/usr/bin/do_mount", "-o", option, dname, target)
+		cmd.Stderr = os.Stderr
+		_, errb := cmd.Output()
+		if errb != nil {
+			log.Infof("exec /usr/bin/do_mount, failed.")
+			log.Infof("Mouting %s failed", display)
+			return err
+		}
+		return nil
 
-	if err != nil {
-		return err
+	} else {
+		
+		dev := util.ResolveDevice(dname)
+		if dev == "" {
+			return fmt.Errorf("Could not resolve device %q", dev)
+		}
+		if fsType == "auto" {
+			fsType, err = util.GetFsType(dev)
+		}
+
+		if err != nil {
+			return err
+		}
+		log.Debugf("FsType has been set to %s", fsType)
+		log.Infof("Mounting %s device %s to %s", display, dev, target)
+		return util.Mount(dev, target, fsType, option)
 	}
 
-	log.Debugf("FsType has been set to %s", fsType)
-	log.Infof("Mounting %s device %s to %s", display, dev, target)
-	return util.Mount(dev, target, fsType, "")
 }
 
 func mountState(cfg *config.CloudConfig) error {
-	return mountConfigured("state", cfg.Rancher.State.Dev, cfg.Rancher.State.FsType, config.StateDir)
+	return mountConfigured("state", cfg.Rancher.State.Dev, cfg.Rancher.State.FsType, config.StateDir, cfg.Rancher.State.MountOpt)
 }
 
 func tryMountState(cfg *config.CloudConfig) error {
diff -Naur '--exclude=.git' os.prev/pkg/init/prepare/prepare.go os.new/pkg/init/prepare/prepare.go
--- os.prev/pkg/init/prepare/prepare.go	2024-02-15 15:45:46.760000000 +0900
+++ os.new/pkg/init/prepare/prepare.go	2024-02-20 16:23:46.720416200 +0900
@@ -3,6 +3,7 @@
 import (
 	"os"
 	"strings"
+	"os/exec"
 
 	"github.com/burmilla/os/config"
 	"github.com/burmilla/os/pkg/dfs"
@@ -37,5 +38,13 @@
 		log.SetLevel(log.InfoLevel)
 	}
 
+	log.Infof("executing /sbin/after_save_cmd_line")
+	cmd := exec.Command("/sbin/after_save_cmd_line")
+	cmd.Stderr = os.Stderr
+	_, errb := cmd.Output()
+	if errb != nil {
+		log.Infof("exec /sbin/after_save_cmd_line failed.")
+	}
+
 	return cfg, nil
 }
diff -Naur '--exclude=.git' os.prev/pkg/init/switchroot/switchroot.go os.new/pkg/init/switchroot/switchroot.go
--- os.prev/pkg/init/switchroot/switchroot.go	2024-02-15 15:45:46.760000000 +0900
+++ os.new/pkg/init/switchroot/switchroot.go	2024-02-21 10:40:06.455314500 +0900
@@ -141,6 +141,7 @@
 		if err := syscall.Mount(i, path.Join(rootfs, i), "", syscall.MS_MOVE, ""); err != nil {
 			return err
 		}
+		os.Symlink(path.Join(rootfs, i), i)
 	}
 
 	if err := copyMoveRoot(rootfs, rmUsr); err != nil {
@@ -158,6 +159,7 @@
 	}
 
 	log.Debug("chroot .")
+
 	if err := syscall.Chroot("."); err != nil {
 		return err
 	}
diff -Naur '--exclude=.git' os.prev/pkg/log/log.go os.new/pkg/log/log.go
--- os.prev/pkg/log/log.go	2024-02-15 15:45:46.760000000 +0900
+++ os.new/pkg/log/log.go	2024-02-21 21:00:01.695314500 +0900
@@ -2,9 +2,12 @@
 
 import (
 	"fmt"
+	"time"
+  "strconv"
 	"io"
 	"log/syslog"
 	"os"
+	"os/exec"
 	"path/filepath"
 	"strings"
 
@@ -18,6 +21,9 @@
 var userHook *ShowuserlogHook
 var defaultLogLevel logrus.Level
 var debugThisLogger = false
+var preservedLogs = ""
+var preserveLogFN = ""
+var doPreserve = false
 
 type Fields logrus.Fields
 type Level logrus.Level
@@ -63,28 +69,74 @@
 	return Level(logrus.GetLevel())
 }
 
+
+func UntilLogWritable(lgFName string){
+	preserveLogFN = lgFName
+	fmt.Printf("setting log file, '%s'\n", preserveLogFN)
+}
+
+
+func mayRedirect(lv string, format string, args ...interface{}) {
+	if preserveLogFN != "" {
+		t := time.Now()
+		_, err := os.Stat(preserveLogFN)
+		if err != nil { // file missing
+			fmt.Printf("file missing, '%s'\n", preserveLogFN)
+			doPreserve = true
+		} else { // file exists
+			fmt.Printf("file found, '%s'\n", preserveLogFN)
+			if doPreserve {
+				 // write preserved
+				file, err := os.OpenFile(preserveLogFN, os.O_WRONLY|os.O_APPEND)
+				if err == nil {
+					fmt.Printf("file opened, '%s'", preserveLogFN)
+					_, err := file.WriteString(preservedLogs)
+					if err == nil {
+						fmt.Printf("written preserved log\n")
+						file.Close()
+					}
+				}
+				preserveLogFN = ""
+				doPreserve = false
+			}
+		}
+		if doPreserve {
+			preservedLogs += "time=" + t.String() + " level=" + lv + " " + " msg=\"" + fmt.Sprintf(format, args...) + "\"" + "\n"
+		}
+	}
+}
+
+
 func Debugf(format string, args ...interface{}) {
+	mayRedirect("debug", format, args...)
 	logrus.Debugf(format, args...)
 }
 func Infof(format string, args ...interface{}) {
+	mayRedirect("info", format, args...)
 	logrus.Infof(format, args...)
 }
 func Printf(format string, args ...interface{}) {
+	mayRedirect("print", format, args...)
 	logrus.Printf(format, args...)
 }
 func Warnf(format string, args ...interface{}) {
+	mayRedirect("warning", format, args...)
 	logrus.Warnf(format, args...)
 }
 func Warningf(format string, args ...interface{}) {
+	mayRedirect("warning", format, args...)
 	logrus.Warningf(format, args...)
 }
 func Errorf(format string, args ...interface{}) {
+	mayRedirect("error", format, args...)
 	logrus.Errorf(format, args...)
 }
 func Fatalf(format string, args ...interface{}) {
+	mayRedirect("fatal", format, args...)
 	logrus.Fatalf(format, args...)
 }
 func Panicf(format string, args ...interface{}) {
+	mayRedirect("panic", format, args...)
 	logrus.Panicf(format, args...)
 }
 
@@ -122,6 +174,23 @@
 
 // InitLogger sets up Logging to log to /dev/kmsg and to Syslog
 func InitLogger() {
+	out, errb := exec.Command("/usr/bin/date", "%z").Output()
+	if errb != nil {
+		Errorf("exec /usr/bin/date, failed.")
+	} else {
+		td := string(out)
+		Infof("output of `date %z`: %s", td)
+		a, _ := strconv.Atoi(td[1:3])
+		b, _ := strconv.Atoi(td[3:])
+		base := a * 60 * 60 + b * 60
+		if td[0:1] == "-" {
+			base = -base
+		}
+		Infof("time difference: %d seconds", base)
+		loc := time.FixedZone("INIT_LOCAL", base)
+		time.Local = loc
+		Infof("set time zone")
+	}
 	if logTheseApps() {
 		innerInit(false)
 		FsReady()
diff -Naur '--exclude=.git' os.prev/pkg/sysinit/sysinit.go os.new/pkg/sysinit/sysinit.go
--- os.prev/pkg/sysinit/sysinit.go	2024-02-15 15:45:46.760000000 +0900
+++ os.new/pkg/sysinit/sysinit.go	2024-02-20 16:23:46.720416200 +0900
@@ -93,6 +93,14 @@
 }
 
 func SysInit() error {
+	log.Infof("executing /sbin/before_sysinit")
+	cmd := exec.Command("/sbin/before_sysinit")
+	cmd.Stderr = os.Stderr
+	_, errb := cmd.Output()
+	if errb != nil {
+		log.Infof("exec /sbin/before_sysinit failed.")
+	}
+
 	cfg := config.LoadConfig()
 
 	if err := control.PreloadImages(docker.NewSystemClient, systemImagesPreloadDirectory); err != nil {
diff -Naur '--exclude=.git' os.prev/scripts/version os.new/scripts/version
--- os.prev/scripts/version	2024-02-15 15:45:46.770000000 +0900
+++ os.new/scripts/version	2024-02-20 16:23:46.720416200 +0900
@@ -1,18 +1,26 @@
 #!/bin/bash
 
-if [ -n "$(git status --porcelain --untracked-files=no)" ]; then
-    DIRTY="-dirty"
-fi
+#if [ -n "$(git status --porcelain --untracked-files=no)" ]; then
+#    DIRTY="-dirty"
+#fi
 
 COMMIT=$(git rev-parse --short HEAD)
 GIT_TAG=$(git tag -l --contains HEAD | head -n 1)
 
-if [ -z "$VERSION" ]; then
-    if [[ -z "$DIRTY" && -n "$GIT_TAG" ]]; then
-        VERSION=$GIT_TAG
-    else
-        VERSION="${COMMIT}${DIRTY}"
-    fi
+#if [ -z "$VERSION" ]; then
+#    if [[ -z "$DIRTY" && -n "$GIT_TAG" ]]; then
+#        VERSION=$GIT_TAG-btrfs-0.9
+#    else
+#        VERSION="${COMMIT}${DIRTY}"
+#    fi
+#fi
+
+if [ ! -e ../.git/packed-refs ]; then
+	VERSION=`cat /tmp/version.patched`
+else
+	TTAG=`tail -1 ../.git/packed-refs`
+	VERSION=${TTAG##*/}-btrfs-__PVER__
+	echo -n $VERSION > /tmp/version.patched
 fi
 
 INITRD=initrd-${VERSION}

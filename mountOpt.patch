diff -Naur '--exclude=.git' os.prev/cmd/control/autologin.go os.new/cmd/control/autologin.go
--- os.prev/cmd/control/autologin.go	2024-03-14 20:29:45.937485300 +0900
+++ os.new/cmd/control/autologin.go	2024-05-14 14:04:35.527314900 +0900
@@ -75,9 +75,9 @@
 	os.Setenv("TERM", "linux")
 
 	// Causes all sorts of issues
-	//return syscall.Exec(loginBinPath, args, os.Environ())
+	//return syscall.Exec(loginBinPath, args, config.Environ())
 	cmd = exec.Command(loginBinPath, args...)
-	cmd.Env = os.Environ()
+	cmd.Env = config.Environ()
 
 	cmd.Stderr = os.Stderr
 	cmd.Stdout = os.Stdout
diff -Naur '--exclude=.git' os.prev/cmd/control/config.go os.new/cmd/control/config.go
--- os.prev/cmd/control/config.go	2024-03-14 20:29:45.937485300 +0900
+++ os.new/cmd/control/config.go	2024-05-14 14:04:35.527314900 +0900
@@ -143,7 +143,7 @@
 		log.Fatal("Could not read from stdin")
 	}
 	tpl := template.Must(template.New("osconfig").Parse(string(bytes)))
-	return tpl.Execute(out, env2map(os.Environ()))
+	return tpl.Execute(out, env2map(config.Environ()))
 }
 
 func env2map(env []string) map[string]string {
diff -Naur '--exclude=.git' os.prev/cmd/control/console_init.go os.new/cmd/control/console_init.go
--- os.prev/cmd/control/console_init.go	2024-03-14 20:29:45.937485300 +0900
+++ os.new/cmd/control/console_init.go	2024-05-14 14:04:35.527314900 +0900
@@ -259,6 +259,37 @@
 	if err := cmd.Run(); err != nil {
 		log.Error(err)
 	}
+	
+	cmd = exec.Command("stat", "-f", "-c", "%T", "/opt")
+	out, errb := cmd.Output()
+	if errb != nil {
+		log.Error("exec stat -f -c %T /opt, failed.")
+	}else{
+		if strings.Index(string(out), "ramfs") != -1 {
+			file, err := os.OpenFile("/etc/issue", os.O_APPEND|os.O_WRONLY, 0600)
+			if err != nil {
+				log.Error(err)
+			} else {
+				defer file.Close()
+				exec.Command("bash", "-c", `echo -n $(/sbin/ifconfig | grep -B1 "inet" |awk '{ if ( $1 == "inet" ) { print $2 } else if ( $3 == "mtu" ) { printf "%s:" ,$1 } }' |awk -F: '{ print $1 ": " $3}' | egrep -o ': [0-9a-f:\.]+' | head -1 | egrep -o '[0-9a-fA-F][0-9a-fA-F:\.]+') > /etc/main_ip`).Run()
+				content, err := ioutil.ReadFile("/etc/main_ip")
+				if err == nil && string(content) != "" {
+					_, err = file.WriteString(`
+For installation, please execute:
+  wget http://` + string(content) + `/install.sh -q -O - \| bash -s SERVER_NAME FIXED_IP SSH_PORT DEVICE
+    SERVER_NAME : New server name, ex. 'serv1.foo.com'
+    FIXED_IP    : New fixed IPv4 address for the system, ex. '10.1.1.1'
+    SSH_PORT	: SSH port number for the system, ex. '20022'
+    DEVICE      : Device name on which the system is installed, ex. '/dev/sdc'
+from your terminal.
+` )
+				}
+				if err != nil {
+					log.Error(err)
+ 				}
+ 			}
+		}
+	}
 
 	cloudinitexecute.ApplyConsole(cfg)
 
@@ -293,7 +324,7 @@
 		return err
 	}
 
-	return syscall.Exec(respawnBinPath, []string{"respawn", "-f", "/etc/respawn.conf"}, os.Environ())
+	return syscall.Exec(respawnBinPath, []string{"respawn", "-f", "/etc/respawn.conf"}, config.Environ())
 }
 
 func generateRespawnConf(cmdline, user string, sshd, recovery bool) string {
diff -Naur '--exclude=.git' os.prev/cmd/control/docker_init.go os.new/cmd/control/docker_init.go
--- os.prev/cmd/control/docker_init.go	2024-03-14 20:29:45.937485300 +0900
+++ os.new/cmd/control/docker_init.go	2024-05-14 14:04:35.527314900 +0900
@@ -112,5 +112,5 @@
 		log.Error(err)
 	}
 
-	return syscall.Exec("/bin/bash", args, os.Environ())
+	return syscall.Exec("/bin/bash", args, config.Environ())
 }
diff -Naur '--exclude=.git' os.prev/cmd/control/entrypoint.go os.new/cmd/control/entrypoint.go
--- os.prev/cmd/control/entrypoint.go	2024-03-14 20:29:45.937485300 +0900
+++ os.new/cmd/control/entrypoint.go	2024-05-14 14:04:35.527314900 +0900
@@ -55,8 +55,8 @@
 	if err != nil {
 		return err
 	}
-
-	return syscall.Exec(binary, os.Args[2:], os.Environ())
+	
+	return syscall.Exec(binary, os.Args[2:], config.Environ())
 }
 
 func writeFiles(cfg *config.CloudConfig) error {
diff -Naur '--exclude=.git' os.prev/cmd/control/env.go os.new/cmd/control/env.go
--- os.prev/cmd/control/env.go	2024-03-14 20:29:45.937485300 +0900
+++ os.new/cmd/control/env.go	2024-05-14 14:04:35.537314900 +0900
@@ -2,7 +2,6 @@
 
 import (
 	"log"
-	"os"
 	"os/exec"
 	"syscall"
 
@@ -19,7 +18,7 @@
 	if len(args) == 0 {
 		return nil
 	}
-	osEnv := os.Environ()
+	osEnv := config.Environ()
 
 	envMap := make(map[string]string, len(cfg.Rancher.Environment)+len(osEnv))
 	for k, v := range cfg.Rancher.Environment {
diff -Naur '--exclude=.git' os.prev/cmd/control/install.go os.new/cmd/control/install.go
--- os.prev/cmd/control/install.go	2024-03-14 20:29:45.937485300 +0900
+++ os.new/cmd/control/install.go	2024-05-14 14:04:35.537314900 +0900
@@ -201,6 +201,11 @@
 func runInstall(image, installType, cloudConfig, device, partition, statedir, kappend string, force, kexec, isoinstallerloaded, debug bool, savedImages []string) error {
 	fmt.Printf("Installing from %s\n", image)
 
+	if os.Getenv("ROS_BTRFS_WRAPPER") == "" {
+		log.Errorf("You cannot execute ros install or upgrade command directly.")
+		fmt.Println("You cannot execute ros install or upgrade command directly, terminate the task.")
+		os.Exit(1)
+	}
 	if !force {
 		if util.IsRunningInTty() && !yes("Continue") {
 			log.Infof("Not continuing with installation due to user not saying 'yes'")
@@ -223,14 +228,14 @@
 			if err = mountBootIso(deviceName, deviceType); err != nil {
 				log.Debugf("Failed to mountBootIso: %v", err)
 			} else {
-				log.Infof("trying to load /bootiso/rancheros/installer.tar.gz")
+				log.Infof("trying to load /bootiso/rancheros/fullinstaller.tar.gz")
 				if _, err := os.Stat("/bootiso/rancheros/"); err == nil {
-					cmd := exec.Command("system-docker", "load", "-i", "/bootiso/rancheros/installer.tar.gz")
+					cmd := exec.Command("system-docker", "load", "-i", "/bootiso/rancheros/fullinstaller.tar.gz")
 					cmd.Stdout, cmd.Stderr = os.Stdout, os.Stderr
 					if err := cmd.Run(); err != nil {
 						log.Infof("failed to load images from /bootiso/rancheros: %v", err)
 					} else {
-						log.Infof("Loaded images from /bootiso/rancheros/installer.tar.gz")
+						log.Infof("Loaded images from /bootiso/rancheros/fullinstaller.tar.gz")
 
 						//TODO: add if os-installer:latest exists - we might have loaded a full installer?
 						useIso = true
@@ -247,11 +252,14 @@
 			}
 
 			log.Infof("starting installer container for %s (new)", image)
+			ros_btrfs_wrapper := os.Getenv("ROS_BTRFS_WRAPPER")
 			installerCmd := []string{
 				"run", "--rm", "--net=host", "--privileged",
 				// bind mount host fs to access its ros, vmlinuz, initrd and /dev (udev isn't running in container)
 				"-v", "/:/host",
 				"--volumes-from=all-volumes",
+				"-e",
+				"ROS_BTRFS_WRAPPER=" + ros_btrfs_wrapper,
 				image,
 				//				"install",
 				"-t", installType,
diff -Naur '--exclude=.git' os.prev/cmd/control/recovery_init.go os.new/cmd/control/recovery_init.go
--- os.prev/cmd/control/recovery_init.go	2024-03-14 20:29:45.937485300 +0900
+++ os.new/cmd/control/recovery_init.go	2024-05-14 14:04:35.537314900 +0900
@@ -1,11 +1,11 @@
 package control
 
 import (
-	"os"
 	"os/exec"
 	"syscall"
 
 	"github.com/burmilla/os/pkg/log"
+	"github.com/burmilla/os/config"
 
 	"github.com/codegangsta/cli"
 )
@@ -20,5 +20,5 @@
 		return err
 	}
 
-	return syscall.Exec(respawnBinPath, []string{"respawn", "-f", "/etc/respawn.conf"}, os.Environ())
+	return syscall.Exec(respawnBinPath, []string{"respawn", "-f", "/etc/respawn.conf"}, config.Environ())
 }
diff -Naur '--exclude=.git' os.prev/cmd/control/user_docker.go os.new/cmd/control/user_docker.go
--- os.prev/cmd/control/user_docker.go	2024-03-14 20:29:45.937485300 +0900
+++ os.new/cmd/control/user_docker.go	2024-05-14 14:04:35.537314900 +0900
@@ -193,7 +193,7 @@
 	cmd = append(cmd, args...)
 	log.Infof("Running %v", cmd)
 
-	return syscall.Exec("/usr/bin/system-docker-runc", cmd, os.Environ())
+	return syscall.Exec("/usr/bin/system-docker-runc", cmd, config.Environ())
 }
 
 func waitForPid(service string, project *project.Project) (int, error) {
diff -Naur '--exclude=.git' os.prev/cmd/init/init.go os.new/cmd/init/init.go
--- os.prev/cmd/init/init.go	2024-03-14 20:29:45.937485300 +0900
+++ os.new/cmd/init/init.go	2024-05-14 14:04:35.537314900 +0900
@@ -5,7 +5,8 @@
 
 import (
 	"fmt"
-
+	"os/exec"
+	"time"
 	"github.com/burmilla/os/config"
 	"github.com/burmilla/os/pkg/dfs"
 	"github.com/burmilla/os/pkg/init/b2d"
@@ -38,6 +39,14 @@
 
 	if err := RunInit(); err != nil {
 		log.Fatal(err)
+		dmsg, errb := exec.Command("bash", "-c", "dmesg | tail -10").Output()
+		if errb == nil {
+			log.Warnf("%s", string(dmsg))
+		}
+		log.Warnf("Continue by chrooting.", err)
+		if errb != nil {
+			log.Warnf("cannot exec dmesg (Error:%v)", errb)
+		}
 	}
 }
 
@@ -79,7 +88,9 @@
 	log.Info("Launching System Docker")
 	_, err = dfs.LaunchDocker(launchConfig, config.SystemDockerBin, args...)
 	if err != nil {
+		time.Sleep(3 * time.Second)
 		log.Errorf("Error Launching System Docker: %s", err)
+		time.Sleep(3 * time.Second)
 		recovery.Recovery(err)
 		return err
 	}
diff -Naur '--exclude=.git' os.prev/config/config.go os.new/config/config.go
--- os.prev/config/config.go	2024-03-14 20:29:45.957485300 +0900
+++ os.new/config/config.go	2024-05-14 14:04:35.537314900 +0900
@@ -2,13 +2,18 @@
 
 import (
 	"io/ioutil"
+	"io"
+	"os"
 	"strings"
 
+	"github.com/burmilla/os/pkg/log"
 	"github.com/burmilla/os/config/cmdline"
 	"github.com/burmilla/os/pkg/util"
 	yaml "github.com/cloudfoundry-incubator/candiedyaml"
 )
 
+var nenv []string
+
 const Banner = `
     ____                       _ _ _        ____   _____
    |  _ \\                     (_) | |      / __ \\ / ____|
@@ -94,3 +99,37 @@
 	elem := strings.Split(string(b), " ")
 	return elem[2]
 }
+
+func Environ() []string {
+	tz := ""
+	if os.Getenv("TZ") == "" {
+		log.Debug("Trying read /proc/cmdline")
+		file, err := os.Open("/proc/cmdline")
+		if err == nil { // file exists
+			byteData, err := io.ReadAll(file)
+			if err == nil {
+				cmdline := string(byteData)
+				log.Debugf("/proc/cmdline = $s", cmdline)
+				ti := strings.Index(cmdline, " TZ=")
+				if ti != -1 {
+					tw := strings.Index(cmdline[ti + 4:], " ")
+					if tw != -1 {
+						tz = cmdline[ti + 4:ti + 4 + tw]
+						log.Debugf("TZ = %s", tz)
+					}
+				}else{
+					log.Debugf("cannot find 'TZ=' in /proc/cmdline")
+				}
+			}else{
+				log.Debugf("cannot read /proc/cmdline")
+			}
+			file.Close()
+		}else{
+			log.Debugf("cannot open /proc/cmdline")
+		}
+		nenv = append(os.Environ(), "TZ=" + tz)
+	}else{
+		nenv = os.Environ()
+	}
+	return nenv
+}
diff -Naur '--exclude=.git' os.prev/config/docker_config.go os.new/config/docker_config.go
--- os.prev/config/docker_config.go	2024-03-14 20:29:45.957485300 +0900
+++ os.new/config/docker_config.go	2024-05-14 14:04:35.547314900 +0900
@@ -2,9 +2,12 @@
 
 import (
 	"fmt"
+	"io"
 	"os"
+	"strings"
 
 	"github.com/fatih/structs"
+	"github.com/burmilla/os/pkg/log"
 )
 
 func (d *DockerConfig) FullArgs() []string {
@@ -23,8 +26,43 @@
 	return args
 }
 
+
+func environ() []string {
+	tz := ""
+	if os.Getenv("TZ") == "" {
+		log.Debug("Trying read /proc/cmdline")
+		file, err := os.Open("/proc/cmdline")
+		if err == nil { // file exists
+			byteData, err := io.ReadAll(file)
+			if err == nil {
+				cmdline := string(byteData)
+				log.Debugf("/proc/cmdline = $s", cmdline)
+				ti := strings.Index(cmdline, " TZ=")
+				if ti != -1 {
+					tw := strings.Index(cmdline[ti + 4:], " ")
+					if tw != -1 {
+						tz = cmdline[ti + 4:ti + 4 + tw]
+						log.Debugf("TZ = %s", tz)
+					}
+				}else{
+					log.Debugf("cannot find 'TZ=' in /proc/cmdline")
+				}
+			}else{
+				log.Debugf("cannot read /proc/cmdline")
+			}
+			file.Close()
+		}else{
+			log.Debugf("cannot open /proc/cmdline")
+		}
+		nenv = append(os.Environ(), "TZ=" + tz)
+	}else{
+		nenv = os.Environ()
+	}
+	return nenv
+}
+
 func (d *DockerConfig) AppendEnv() []string {
-	return append(os.Environ(), d.Environment...)
+	return append(environ(), d.Environment...)
 }
 
 func generateEngineOptsSlice(opts EngineOpts) []string {
diff -Naur '--exclude=.git' os.prev/config/types.go os.new/config/types.go
--- os.prev/config/types.go	2024-03-14 20:29:45.957485300 +0900
+++ os.new/config/types.go	2024-05-14 14:04:35.547314900 +0900
@@ -210,6 +210,7 @@
 type StateConfig struct {
 	Directory  string   `yaml:"directory,omitempty"`
 	FsType     string   `yaml:"fstype,omitempty"`
+	MountOpt     string   `yaml:"mountopt,omitempty"`
 	Dev        string   `yaml:"dev,omitempty"`
 	Wait       bool     `yaml:"wait,omitempty"`
 	Required   bool     `yaml:"required,omitempty"`
@@ -220,8 +221,10 @@
 	Rngd       bool     `yaml:"rngd,omitempty"`
 	Script     string   `yaml:"script,omitempty"`
 	OemFsType  string   `yaml:"oem_fstype,omitempty"`
+	OemMountOpt  string   `yaml:"oem_mountopt,omitempty"`
 	OemDev     string   `yaml:"oem_dev,omitempty"`
 	BootFsType string   `yaml:"boot_fstype,omitempty"`
+	BootMountOpt string   `yaml:"boot_mountopt,omitempty"`
 	BootDev    string   `yaml:"boot_dev,omitempty"`
 }
 
diff -Naur '--exclude=.git' os.prev/images/02-console/sshd_config.append.tpl os.new/images/02-console/sshd_config.append.tpl
--- os.prev/images/02-console/sshd_config.append.tpl	2024-03-14 20:29:45.967485300 +0900
+++ os.new/images/02-console/sshd_config.append.tpl	2024-05-14 14:18:28.167314900 +0900
@@ -22,6 +22,7 @@
 PermitEmptyPasswords no
 AllowTcpForwarding no
 DebianBanner no
+PasswordAuthentication no
 
 # Restrict key exchange, cipher, and MAC algorithms, as per sshaudit.com hardening guide.
 KexAlgorithms curve25519-sha256,curve25519-sha256@libssh.org,diffie-hellman-group16-sha512,diffie-hellman-group18-sha512,diffie-hellman-group-exchange-sha256
diff -Naur '--exclude=.git' os.prev/install_burmillaos_on_btrfs os.new/install_burmillaos_on_btrfs
--- os.prev/install_burmillaos_on_btrfs	1970-01-01 09:00:00.000000000 +0900
+++ os.new/install_burmillaos_on_btrfs	2024-05-14 14:04:35.547314900 +0900
@@ -0,0 +1 @@
+
diff -Naur '--exclude=.git' os.prev/main.go os.new/main.go
--- os.prev/main.go	2024-03-14 20:29:45.967485300 +0900
+++ os.new/main.go	2024-05-14 14:04:35.547314900 +0900
@@ -3,6 +3,10 @@
 import (
 	"fmt"
 	"os"
+    "strconv"
+    "time"
+    "io"
+	"strings"
 
 	"github.com/burmilla/os/cmd/cloudinitexecute"
 	"github.com/burmilla/os/cmd/cloudinitsave"
@@ -39,6 +43,32 @@
 }
 
 func main() {
+	tzs := os.Getenv("TZS")
+	base := 0
+	if tzs != "" {
+		base, _ = strconv.Atoi(tzs)
+	}
+	if base == 0 {
+		file, err := os.Open("/proc/cmdline")
+		if err == nil { // file exists
+			byteData, err := io.ReadAll(file)
+			if err == nil {
+				cmdline := string(byteData)
+				ti := strings.Index(cmdline, " TZS=")
+				if ti != -1 {
+					tw := strings.Index(cmdline[ti + 5:], " ")
+					if tw != -1 {
+						base, _ = strconv.Atoi(cmdline[ti + 5:ti + 5 + tw])
+					}
+				}
+			}
+			file.Close()
+		}
+	}
+	if base != 0 {
+		time.FixedZone("LOCAL", base)
+	}
+
 	if 0 == 1 {
 		// TODO: move this into a "dev/debug +build"
 		fmt.Fprintf(os.Stderr, "ros main(%s) ppid:%d - print to stdio\n", os.Args[0], os.Getppid())
diff -Naur '--exclude=.git' os.prev/pkg/dfs/scratch.go os.new/pkg/dfs/scratch.go
--- os.prev/pkg/dfs/scratch.go	2024-03-14 20:29:45.967485300 +0900
+++ os.new/pkg/dfs/scratch.go	2024-05-14 14:04:35.547314900 +0900
@@ -11,6 +11,7 @@
 	"strings"
 	"syscall"
 
+	"github.com/burmilla/os/config"
 	"github.com/burmilla/os/config/cmdline"
 	"github.com/burmilla/os/pkg/init/one"
 	"github.com/burmilla/os/pkg/log"
@@ -172,20 +173,20 @@
 	return nil
 }
 
-func execDocker(config *Config, docker, cmd string, args []string) (*exec.Cmd, error) {
+func execDocker(config_ *Config, docker, cmd string, args []string) (*exec.Cmd, error) {
 	if len(args) > 0 && args[0] == "docker" {
 		args = args[1:]
 	}
 	log.Debugf("Launching Docker %s %s %v", docker, cmd, args)
 
-	env := os.Environ()
-	if len(config.Environment) != 0 {
-		env = append(env, config.Environment...)
+	env := config.Environ()
+	if len(config_.Environment) != 0 {
+		env = append(env, config_.Environment...)
 	}
 
-	if config.Fork {
+	if config_.Fork {
 		cmd := exec.Command(docker, args...)
-		if !config.NoLog {
+		if !config_.NoLog {
 			cmd.Stdout = os.Stdout
 			cmd.Stderr = os.Stderr
 		}
@@ -194,7 +195,7 @@
 		if err != nil {
 			return cmd, err
 		}
-		if config.PidOne {
+		if config_.PidOne {
 			one.PidOne()
 		}
 		return cmd, err
diff -Naur '--exclude=.git' os.prev/pkg/init/configfiles/configfiles.go os.new/pkg/init/configfiles/configfiles.go
--- os.prev/pkg/init/configfiles/configfiles.go	2024-03-14 20:29:45.967485300 +0900
+++ os.new/pkg/init/configfiles/configfiles.go	2024-05-14 14:04:35.547314900 +0900
@@ -55,6 +55,7 @@
 			ConfigFiles[name] = content
 		}
 	}
+	log.UntilLogWritable("/var/log/boot/init.log")
 	return cfg, nil
 }
 
diff -Naur '--exclude=.git' os.prev/pkg/init/fsmount/fsmount.go os.new/pkg/init/fsmount/fsmount.go
--- os.prev/pkg/init/fsmount/fsmount.go	2024-03-14 20:29:45.967485300 +0900
+++ os.new/pkg/init/fsmount/fsmount.go	2024-05-14 14:17:23.707314900 +0900
@@ -4,6 +4,8 @@
 	"fmt"
 	"strings"
 	"syscall"
+	"os"
+	"os/exec"
 
 	"github.com/burmilla/os/config"
 	"github.com/burmilla/os/config/cmdline"
@@ -18,16 +20,16 @@
 )
 
 var (
+	MountDegraded = false
 	ShouldSwitchRoot bool
 )
 
 func MountOem(cfg *config.CloudConfig) (*config.CloudConfig, error) {
-	if err := mountConfigured("oem", cfg.Rancher.State.OemDev, cfg.Rancher.State.OemFsType, config.OemDir); err != nil {
+	if err := mountConfigured("oem", cfg.Rancher.State.OemDev, cfg.Rancher.State.OemFsType, config.OemDir, cfg.Rancher.State.OemMountOpt); err != nil {
 		log.Debugf("Not mounting OEM: %v", err)
 	} else {
 		log.Infof("Mounted OEM: %s", cfg.Rancher.State.OemDev)
 	}
-
 	return cfg, nil
 }
 
@@ -45,7 +47,7 @@
 		}
 	}
 
-	if err := mountConfigured("boot", cfg.Rancher.State.BootDev, cfg.Rancher.State.BootFsType, config.BootDir); err != nil {
+	if err := mountConfigured("boot", cfg.Rancher.State.BootDev, cfg.Rancher.State.BootFsType, config.BootDir, cfg.Rancher.State.BootMountOpt); err != nil {
 		log.Debugf("Not mounting BOOT: %v", err)
 	} else {
 		log.Infof("Mounted BOOT: %s", cfg.Rancher.State.BootDev)
@@ -54,32 +56,51 @@
 	return cfg, nil
 }
 
-func mountConfigured(display, dev, fsType, target string) error {
-	var err error
+func mountConfigured(display, dname, fsType, target, option string) error {
+
 
-	if dev == "" {
+	if dname == "" {
 		return nil
 	}
 
-	dev = util.ResolveDevice(dev)
-	if dev == "" {
-		return fmt.Errorf("Could not resolve device %q", dev)
-	}
-	if fsType == "auto" {
-		fsType, err = util.GetFsType(dev)
-	}
+	log.Infof("Mounting %s device %s to %s (option = '%s')", display, dname, target, option)
 
-	if err != nil {
-		return err
+	if _, err := os.Stat("/usr/bin/do_mount"); err == nil {
+		cmd := exec.Command("/usr/bin/do_mount", "--verbose", "-o", option, dname, target)
+		cmd.Stderr = os.Stderr
+		errb := cmd.Run()
+		if errb != nil {
+			log.Infof("exec /usr/bin/do_mount, failed!")
+			log.Infof("Mouting %s failed!", display)
+			return err
+		}
+		if _, err := os.Stat("/var/tmp/do_mount/degraded"); err == nil {
+			MountDegraded = true
+		}
+		return nil
+
+	} else {
+		log.Warn("'do_mount' is not found.")
+		dev := util.ResolveDevice(dname)
+		if dev == "" {
+			return fmt.Errorf("Could not resolve device %q", dev)
+		}
+		if fsType == "auto" {
+			fsType, err = util.GetFsType(dev)
+		}
+
+		if err != nil {
+			return err
+		}
+		log.Debugf("FsType has been set to %s", fsType)
+		log.Infof("Mounting %s device %s to %s", display, dev, target)
+		return util.Mount(dev, target, fsType, option)
 	}
 
-	log.Debugf("FsType has been set to %s", fsType)
-	log.Infof("Mounting %s device %s to %s", display, dev, target)
-	return util.Mount(dev, target, fsType, "")
 }
 
 func mountState(cfg *config.CloudConfig) error {
-	return mountConfigured("state", cfg.Rancher.State.Dev, cfg.Rancher.State.FsType, config.StateDir)
+	return mountConfigured("state", cfg.Rancher.State.Dev, cfg.Rancher.State.FsType, config.StateDir, cfg.Rancher.State.MountOpt)
 }
 
 func tryMountState(cfg *config.CloudConfig) error {
diff -Naur '--exclude=.git' os.prev/pkg/init/prepare/prepare.go os.new/pkg/init/prepare/prepare.go
--- os.prev/pkg/init/prepare/prepare.go	2024-03-14 20:29:45.967485300 +0900
+++ os.new/pkg/init/prepare/prepare.go	2024-05-14 14:04:35.557314900 +0900
@@ -3,6 +3,7 @@
 import (
 	"os"
 	"strings"
+	"os/exec"
 
 	"github.com/burmilla/os/config"
 	"github.com/burmilla/os/pkg/dfs"
@@ -37,5 +38,13 @@
 		log.SetLevel(log.InfoLevel)
 	}
 
+	log.Infof("executing /sbin/after_save_cmd_line")
+	cmd := exec.Command("/sbin/after_save_cmd_line")
+	cmd.Stderr = os.Stderr
+	_, errb := cmd.Output()
+	if errb != nil {
+		log.Infof("exec /sbin/after_save_cmd_line failed.")
+	}
+
 	return cfg, nil
 }
diff -Naur '--exclude=.git' os.prev/pkg/init/switchroot/switchroot.go os.new/pkg/init/switchroot/switchroot.go
--- os.prev/pkg/init/switchroot/switchroot.go	2024-03-14 20:29:45.967485300 +0900
+++ os.new/pkg/init/switchroot/switchroot.go	2024-05-14 14:17:47.097314900 +0900
@@ -4,9 +4,10 @@
 	"fmt"
 	"io/ioutil"
 	"os"
+	"os/exec"
 	"path"
-	"strings"
 	"syscall"
+	"strings"
 
 	"github.com/burmilla/os/config"
 	"github.com/burmilla/os/pkg/dfs"
@@ -51,12 +52,26 @@
 	return true, nil
 }
 
+func createSymLink(src string, target string) {
+	if err := os.Remove(target); err != nil {
+		log.Infof("$s does not exist", target)
+	}
+
+	if err := os.Symlink(src, target); err != nil{
+		log.Errorf("Cannot create symlink, %s -> %s", src, target)
+	}else{
+		log.Infof("Created symlink, %s -> %s", src, target)
+	}
+}
+
+
 func copyMoveRoot(rootfs string, rmUsr bool) error {
 	usrVer := fmt.Sprintf("usr-%s", config.Version)
 	usr := path.Join(rootfs, usrVer)
 	targetUsr := path.Join(rootfs, "usr")
 	tmpDir := path.Join(rootfs, "tmp")
 
+	
 	if rmUsr {
 		log.Warnf("Development setup. Removing old usr: %s", usr)
 		if err := os.RemoveAll(usr); err != nil {
@@ -109,6 +124,11 @@
 		}
 	}
 
+	createSymLink("usr/bin", path.Join(rootfs, "bin"))
+	createSymLink("usr/lib", path.Join(rootfs, "lib"))
+	createSymLink("lib", path.Join(rootfs, "lib64"))
+	createSymLink("usr/sbin", path.Join(rootfs, "sbin"))
+
 	return nil
 }
 
@@ -141,6 +161,7 @@
 		if err := syscall.Mount(i, path.Join(rootfs, i), "", syscall.MS_MOVE, ""); err != nil {
 			return err
 		}
+		os.Symlink(path.Join(rootfs, i), i)
 	}
 
 	if err := copyMoveRoot(rootfs, rmUsr); err != nil {
@@ -154,10 +175,19 @@
 
 	log.Debugf("mount MS_MOVE %s", rootfs)
 	if err := syscall.Mount(rootfs, "/", "", syscall.MS_MOVE, ""); err != nil {
-		return err
+		log.Warnf("MS_MOVE failed (%v).", err)
+		dmsg, errb := exec.Command("bash", "-c", "dmesg | tail -10").Output()
+		if errb == nil {
+			log.Warnf("%s", string(dmsg))
+		}
+		log.Warnf("Continue by chrooting.", err)
+		if errb != nil {
+			log.Warnf("cannot exec dmesg (Error:%v)", errb)
+		}
 	}
 
 	log.Debug("chroot .")
+
 	if err := syscall.Chroot("."); err != nil {
 		return err
 	}
diff -Naur '--exclude=.git' os.prev/pkg/log/log.go os.new/pkg/log/log.go
--- os.prev/pkg/log/log.go	2024-03-14 20:29:45.967485300 +0900
+++ os.new/pkg/log/log.go	2024-05-14 14:04:35.567314900 +0900
@@ -2,9 +2,14 @@
 
 import (
 	"fmt"
+	"time"
+  "strconv"
 	"io"
 	"log/syslog"
 	"os"
+	"os/exec"
+	"bytes"
+	"syscall"
 	"path/filepath"
 	"strings"
 
@@ -14,10 +19,29 @@
 	lsyslog "github.com/sirupsen/logrus/hooks/syslog"
 )
 
+const (
+	tmpfsMagic int64 = 0x01021994
+	ramfsMagic int64 = 0x858458f6
+	DefaultTimeFormat = "2006-01-02 Mon 15:04:05.000000 -0700"
+	oemVarDir = "/usr/share/ros/oem/var/lib/rancher"
+	oemVarDirInitrd = oemVarDir + "/initrd"
+	timeDiffFN = oemVarDirInitrd + "/time_diff_seconds"
+	initrdInfoDir = "/opt/rancher/initrd"
+	timeDiffFN2 = initrdInfoDir + "/time_diff_seconds"
+	tzFN = oemVarDirInitrd + "/TZ"
+)
+
 var logFile *os.File
 var userHook *ShowuserlogHook
 var defaultLogLevel logrus.Level
 var debugThisLogger = false
+var preservedLogs = ""
+var preserveLogFN = ""
+var doPreserve = false
+var base = 0 // time difference
+var tz = "" // time zone name
+var checkOemVarDir = false
+var initFormatExecuted = false
 
 type Fields logrus.Fields
 type Level logrus.Level
@@ -63,53 +87,145 @@
 	return Level(logrus.GetLevel())
 }
 
+
+func UntilLogWritable(lgFName string){
+	preserveLogFN = lgFName
+	fmt.Printf("setting log file, '%s'\n", preserveLogFN)
+}
+
+func mayRedirect(lv string, format string, args ...interface{}) {
+	msg := fmt.Sprintf(format, args...)
+	_mayRedirect(lv, msg)
+}
+
+func _mayRedirect(lv string, args ...interface{}) {
+	if preserveLogFN != "" {
+		t := time.Now()
+		_, err := os.Stat(preserveLogFN)
+		if err != nil { // file missing
+			doPreserve = true
+		} else { // file exists
+			if doPreserve {
+				 // write preserved
+				file, err := os.OpenFile(preserveLogFN, os.O_WRONLY|os.O_APPEND, 0644)
+				if err == nil {
+					file.WriteString(preservedLogs)
+					file.Close()
+				}
+				preserveLogFN = ""
+				doPreserve = false
+				if base != 0 {
+					checkOemVarDir = true
+				}
+			}
+		}
+		if doPreserve {
+			msg := ""
+			for _, arg := range args{
+				msg += fmt.Sprintf("%v", arg)
+			}
+			preservedLogs += strings.ToUpper(lv + " ")[0:5] + " " + t.Format(DefaultTimeFormat) + " " + msg + "\n"
+		}
+	}
+	if checkOemVarDir {
+		_, err := os.Stat(oemVarDir)
+		if err == nil {
+			checkOemVarDir = false
+			os.Mkdir(oemVarDirInitrd, 0755)
+			file, err := os.Create(timeDiffFN)
+			if err == nil {
+				file.WriteString(fmt.Sprintf("%d", base))
+				file.Close()
+				file, err = os.Create(tzFN)
+				if err == nil {
+					file.WriteString(tz)
+					file.Close()
+				}
+			}
+		}
+	}
+}
+
+
 func Debugf(format string, args ...interface{}) {
+	mayRedirect("DEBUG", format, args...)
+	initFormat()
 	logrus.Debugf(format, args...)
 }
 func Infof(format string, args ...interface{}) {
+	mayRedirect("INFO ", format, args...)
+	initFormat()
 	logrus.Infof(format, args...)
 }
 func Printf(format string, args ...interface{}) {
+	mayRedirect("PRINT", format, args...)
+	initFormat()
 	logrus.Printf(format, args...)
 }
 func Warnf(format string, args ...interface{}) {
+	mayRedirect("WARN ", format, args...)
+	initFormat()
 	logrus.Warnf(format, args...)
 }
 func Warningf(format string, args ...interface{}) {
+	mayRedirect("WARN ", format, args...)
+	initFormat()
 	logrus.Warningf(format, args...)
 }
 func Errorf(format string, args ...interface{}) {
+	mayRedirect("ERROR", format, args...)
+	initFormat()
 	logrus.Errorf(format, args...)
 }
 func Fatalf(format string, args ...interface{}) {
+	mayRedirect("FATAL", format, args...)
+	initFormat()
 	logrus.Fatalf(format, args...)
 }
 func Panicf(format string, args ...interface{}) {
+	mayRedirect("PANIC", format, args...)
+	initFormat()
 	logrus.Panicf(format, args...)
 }
 
 func Debug(args ...interface{}) {
+	_mayRedirect("DEBUG", args...)
+	initFormat()
 	logrus.Debug(args...)
 }
 func Info(args ...interface{}) {
+	_mayRedirect("INFO ", args...)
+	initFormat()
 	logrus.Info(args...)
 }
 func Print(args ...interface{}) {
+	_mayRedirect("PRINT", args...)
+	initFormat()
 	logrus.Print(args...)
 }
 func Warn(args ...interface{}) {
+	_mayRedirect("DEBUG", args...)
+	initFormat()
 	logrus.Warn(args...)
 }
 func Warning(args ...interface{}) {
+	_mayRedirect("WARN ", args...)
+	initFormat()
 	logrus.Warning(args...)
 }
 func Error(args ...interface{}) {
+	_mayRedirect("ERROR", args...)
+	initFormat()
 	logrus.Error(args...)
 }
 func Fatal(args ...interface{}) {
+	_mayRedirect("FATAL", args...)
+	initFormat()
 	logrus.Fatal(args...)
 }
 func Panic(args ...interface{}) {
+	_mayRedirect("PANIC", args...)
+	initFormat()
 	logrus.Panic(args...)
 }
 
@@ -120,8 +236,194 @@
 	return logrus.WithFields(logrus.Fields(fields))
 }
 
+
+func isInitrd() bool {
+	var stat syscall.Statfs_t
+	syscall.Statfs("/", &stat)
+	return int64(stat.Type) == tmpfsMagic || int64(stat.Type) == ramfsMagic
+}
+
+
+type logFormat struct {
+    TimestampFormat string
+}
+
+
+
+//Format function
+func (f *logFormat) Format(entry *logrus.Entry) ([]byte, error) {
+    var b *bytes.Buffer
+
+    if entry.Buffer != nil {
+        b = entry.Buffer
+    } else {
+        b = &bytes.Buffer{}
+    }
+
+    b.WriteString(strings.ToUpper(entry.Level.String() + " ")[0:5])
+    b.WriteString(" ")
+    b.WriteString(entry.Time.Format(f.TimestampFormat))
+
+    if entry.Message != "" {
+        b.WriteString(" ")
+        b.WriteString(entry.Message)
+    }
+
+    if len(entry.Data) > 0 {
+        b.WriteString(" || ")
+    }
+    for key, value := range entry.Data {
+        b.WriteString(key)
+        b.WriteByte('=')
+        b.WriteByte('{')
+        fmt.Fprint(b, value)
+        b.WriteString("}, ")
+    }
+
+    b.WriteByte('\n')
+    return b.Bytes(), nil
+}
+
+
+// InitLogger sets up Logging to log to /dev/kmsg and to Syslog
+func initFormat() {
+	if !initFormatExecuted {
+		initFormatExecuted = true
+		formatter := logFormat{}
+		formatter.TimestampFormat = DefaultTimeFormat
+		logrus.SetFormatter(&formatter)
+		tl := time.Local
+		Debugf("Current time location: %s", tl.String())
+		if tl.String() == "UTC" {
+			tzs := os.Getenv("TZS")
+			if tzs != "" {
+				base, err := strconv.Atoi(tzs)
+				if base != 0 {
+					loc := time.FixedZone("LOCAL", base)
+					time.Local = loc
+					if isInitrd() {
+						os.Mkdir(initrdInfoDir, 0755)
+						file, err := os.Create(timeDiffFN2)
+						if err == nil {
+							file.WriteString(fmt.Sprintf("%d", base))
+							file.Close()
+						}
+					}
+				}
+				if err != nil {
+					Errorf("envromental variable, 'TZS=%s', namely, time difference by seconds, is not a numeric.", tzs)
+				}
+			} else {
+				file, err := os.Open(timeDiffFN2)
+				if err == nil { // file exists
+					byteData, err := io.ReadAll(file)
+					if err == nil {
+						base, _ = strconv.Atoi(string(byteData))
+					}
+					file.Close()
+				}
+			}
+			nullSymlinked := false
+			if base == 0 {
+				_, err := os.Stat("/dev/null")
+				if err != nil { // file missing
+					_, err := os.Stat("/idev/null")
+					if err == nil {
+						os.Symlink("/idev/null", "/dev/null")
+						nullSymlinked = true // initrd started
+					}
+				} else {
+					file, err := os.Open(timeDiffFN)
+					if err == nil { // file exists
+						byteData, err := io.ReadAll(file)
+						file.Close()
+						base, err = strconv.Atoi(string(byteData))
+						if err == nil {
+							file, err := os.Open(tzFN)
+							if err == nil { // file exists
+								byteData, err = io.ReadAll(file)
+								file.Close()
+								tz = strings.TrimSpace(string(byteData))
+							}
+						}
+					}
+				}
+				if err != nil || base == 0 {
+					tz = os.Getenv("TZ")
+					if tz != "" {
+						out, errb := exec.Command("date", "+%z").Output()
+						if errb != nil {
+							out, errb = exec.Command("/usr/bin/date", "+%z").Output()
+							if errb != nil {
+								out, errb = exec.Command("/bin/date", "+%z").Output()
+							}
+						}
+						if errb == nil {
+							td := strings.TrimSpace(string(out))
+							Debugf("output of 'date %%z': %s", td)
+							a, _ := strconv.Atoi(td[1:3])
+							b, _ := strconv.Atoi(td[3:])
+							base = a * 60 * 60 + b * 60
+							if td[0:1] == "-" {
+								base = -base
+							}
+						}else{
+							if(nullSymlinked){
+								Debugf("exec 'date', failed: %v", errb)
+							}
+						}
+					}
+				}
+			}
+			if base == 0 {
+				Debug("Trying read /proc/cmdline")
+				file, err := os.Open("/proc/cmdline")
+				if err == nil { // file exists
+					byteData, err := io.ReadAll(file)
+					if err == nil {
+						cmdline := string(byteData)
+						Debugf("/proc/cmdline = $s", cmdline)
+						ti := strings.Index(cmdline, " TZS=")
+						if ti != -1 {
+							tw := strings.Index(cmdline[ti + 5:], " ")
+							if tw != -1 {
+								base, _ = strconv.Atoi(cmdline[ti + 5:ti + 5 + tw])
+								Debugf("base = %d", base)
+							}
+						}else{
+							Debugf("cannot find 'TZS=' in /proc/cmdline")
+						}
+					}else{
+						Debugf("cannot read /proc/cmdline")
+					}
+					file.Close()
+				}else{
+					Debugf("cannot open /proc/cmdline")
+				}
+			}
+			Debugf("before set: base = %d", base)
+			if base != 0 {
+				if tz == "" {
+					tz = "LOCAL"
+				}
+				loc := time.FixedZone(tz, base)
+				time.Local = loc
+				Debugf("set time zone")
+				Debugf("time difference: %d seconds", base)
+			}
+			if nullSymlinked {
+				os.Remove("/dev/null")
+			}
+		}
+		if isInitrd() {
+			Infof("logger started in initrd.")
+		}
+	}
+}
+
 // InitLogger sets up Logging to log to /dev/kmsg and to Syslog
 func InitLogger() {
+	initFormat()
 	if logTheseApps() {
 		innerInit(false)
 		FsReady()
@@ -131,6 +433,8 @@
 		if err != nil {
 			logrus.Error(err)
 		}
+    	logrus.SetReportCaller(true)
+    	initFormat()
 		logrus.Debugf("START: %v in %s", os.Args, pwd)
 	}
 }
@@ -163,6 +467,7 @@
 		if err != nil {
 			logrus.Error(err)
 		}
+    	initFormat()
 		logrus.Debugf("START: %v in %s", os.Args, pwd)
 	}
 }
@@ -249,8 +554,10 @@
 
 	if debugThisLogger {
 		if deferedHook {
+			initFormat()
 			logrus.Debugf("------------info Starting defered User Hook (%s)", os.Args[0])
 		} else {
+			initFormat()
 			logrus.Debugf("------------info Starting User Hook (%s)", os.Args[0])
 		}
 	}
diff -Naur '--exclude=.git' os.prev/pkg/sysinit/sysinit.go os.new/pkg/sysinit/sysinit.go
--- os.prev/pkg/sysinit/sysinit.go	2024-03-14 20:29:45.967485300 +0900
+++ os.new/pkg/sysinit/sysinit.go	2024-05-14 14:04:35.567314900 +0900
@@ -93,6 +93,14 @@
 }
 
 func SysInit() error {
+	log.Infof("executing /sbin/before_sysinit")
+	cmd := exec.Command("/sbin/before_sysinit")
+	cmd.Stderr = os.Stderr
+	_, errb := cmd.Output()
+	if errb != nil {
+		log.Infof("exec /sbin/before_sysinit failed.")
+	}
+
 	cfg := config.LoadConfig()
 
 	if err := control.PreloadImages(docker.NewSystemClient, systemImagesPreloadDirectory); err != nil {
diff -Naur '--exclude=.git' os.prev/scripts/package-installer os.new/scripts/package-installer
--- os.prev/scripts/package-installer	2024-03-14 20:29:45.977485300 +0900
+++ os.new/scripts/package-installer	2024-05-14 14:04:35.567314900 +0900
@@ -38,13 +38,14 @@
 
 # installer base image - can be included in iso
 # TODO: fix the fullinstaller Dockerfile to use the ${VERSION}${SUFFIX}
+# modified to include fullistaller.tar by Yougain: 20240318
 docker build \
     -t ${OS_REPO}/os-installer \
     --build-arg VERSION=${VERSION} \
     --build-arg KERNEL_VERSION=${KERNEL_VERSION} \
     -f $BASEDOCKERFILE \
     ./scripts/installer
-docker save -o ${ARTIFACTS}/installer.tar ${OS_REPO}/os-installer
+docker save -o ${ARTIFACTS}/fullinstaller.tar ${OS_REPO}/os-installer
 cp $DOCKERFILE ${ARTIFACTS}/
 
 cp ${ARTIFACTS}/${INITRD} ./scripts/installer/build/boot
diff -Naur '--exclude=.git' os.prev/scripts/package-iso os.new/scripts/package-iso
--- os.prev/scripts/package-iso	2024-03-14 20:29:45.977485300 +0900
+++ os.new/scripts/package-iso	2024-05-14 14:04:35.567314900 +0900
@@ -29,9 +29,9 @@
 cp /usr/lib/syslinux/modules/bios/ldlinux.c32  ${CD}/boot/isolinux/
 cp /usr/lib/syslinux/modules/bios/*.c32        ${CD}/boot/isolinux/
 # add the installer image to the iso for non-network / dev/test
-cp ${ARTIFACTS}/installer.tar                  ${CD}/rancheros/
+cp ${ARTIFACTS}/fullinstaller.tar                  ${CD}/rancheros/
 cp ${ARTIFACTS}/Dockerfile.${ARCH}             ${CD}/rancheros/
-gzip ${CD}/rancheros/installer.tar
+gzip ${CD}/rancheros/fullinstaller.tar
 cd ${CD} && xorriso \
     -as mkisofs \
     -l -J -R -V "${DISTRIB_ID}" \
diff -Naur '--exclude=.git' os.prev/scripts/version os.new/scripts/version
--- os.prev/scripts/version	2024-03-14 20:29:45.977485300 +0900
+++ os.new/scripts/version	2024-05-14 14:04:35.567314900 +0900
@@ -1,18 +1,27 @@
 #!/bin/bash
 
-if [ -n "$(git status --porcelain --untracked-files=no)" ]; then
-    DIRTY="-dirty"
-fi
+#if [ -n "$(git status --porcelain --untracked-files=no)" ]; then
+#    DIRTY="-dirty"
+#fi
 
 COMMIT=$(git rev-parse --short HEAD)
 GIT_TAG=$(git tag -l --contains HEAD | head -n 1)
 
-if [ -z "$VERSION" ]; then
-    if [[ -z "$DIRTY" && -n "$GIT_TAG" ]]; then
-        VERSION=$GIT_TAG
-    else
-        VERSION="${COMMIT}${DIRTY}"
-    fi
+#if [ -z "$VERSION" ]; then
+#    if [[ -z "$DIRTY" && -n "$GIT_TAG" ]]; then
+#        VERSION=$GIT_TAG-btrfs-0.9
+#    else
+#        VERSION="${COMMIT}${DIRTY}"
+#    fi
+#fi
+
+if [ ! -e ../.git/packed-refs ]; then
+	VERSION=`cat /tmp/version.patched`
+else
+	#TTAG=`tail -1 ../.git/packed-refs`
+	#VERSION=${TTAG##*/}-btrfs-__PVER__
+	VERSION=${GIT_TAG}-btrfs-__PVER__
+	echo -n $VERSION > /tmp/version.patched
 fi
 
 INITRD=initrd-${VERSION}

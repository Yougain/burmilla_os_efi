diff -Naur '--exclude=.git' os.prev/config/types.go os.new/config/types.go
--- os.prev/config/types.go	2024-02-15 15:45:46.750000000 +0900
+++ os.new/config/types.go	2024-02-19 10:23:58.902499700 +0900
@@ -210,6 +210,7 @@
 type StateConfig struct {
 	Directory  string   `yaml:"directory,omitempty"`
 	FsType     string   `yaml:"fstype,omitempty"`
+	MountOpt     string   `yaml:"mountopt,omitempty"`
 	Dev        string   `yaml:"dev,omitempty"`
 	Wait       bool     `yaml:"wait,omitempty"`
 	Required   bool     `yaml:"required,omitempty"`
@@ -220,9 +221,12 @@
 	Rngd       bool     `yaml:"rngd,omitempty"`
 	Script     string   `yaml:"script,omitempty"`
 	OemFsType  string   `yaml:"oem_fstype,omitempty"`
+	OemMountOpt  string   `yaml:"oem_mountopt,omitempty"`
 	OemDev     string   `yaml:"oem_dev,omitempty"`
 	BootFsType string   `yaml:"boot_fstype,omitempty"`
+	BootMountOpt string   `yaml:"boot_mountopt,omitempty"`
 	BootDev    string   `yaml:"boot_dev,omitempty"`
+	UseUdev    bool     `yaml:"use_udev,omitempty"`
 }
 
 type CloudInit struct {
diff -Naur '--exclude=.git' os.prev/pkg/init/cloudinit/cloudinit.go os.new/pkg/init/cloudinit/cloudinit.go
--- os.prev/pkg/init/cloudinit/cloudinit.go	2024-02-15 15:45:46.760000000 +0900
+++ os.new/pkg/init/cloudinit/cloudinit.go	2024-02-19 10:41:35.342499700 +0900
@@ -4,6 +4,7 @@
 	"io/ioutil"
 	"path/filepath"
 	"strings"
+	"os"
 
 	"github.com/burmilla/os/config"
 	"github.com/burmilla/os/pkg/compose"
@@ -116,6 +117,7 @@
 			{Name: "cloudinit loadImages", Func: sysinit.LoadBootstrapImages},
 			{Name: "cloudinit Services", Func: runCloudInitServiceSet},
 		})
+
 	return err
 }
 
diff -Naur '--exclude=.git' os.prev/pkg/init/fsmount/fsmount.go os.new/pkg/init/fsmount/fsmount.go
--- os.prev/pkg/init/fsmount/fsmount.go	2024-02-15 15:45:46.760000000 +0900
+++ os.new/pkg/init/fsmount/fsmount.go	2024-02-19 11:07:45.132499700 +0900
@@ -1,9 +1,15 @@
 package fsmount
 
 import (
+	"bufio"
+	"bytes"
 	"fmt"
 	"strings"
 	"syscall"
+	"os"
+	"os/exec"
+	"time"
+	"path/filepath"
 
 	"github.com/burmilla/os/config"
 	"github.com/burmilla/os/config/cmdline"
@@ -22,8 +28,8 @@
 )
 
 func MountOem(cfg *config.CloudConfig) (*config.CloudConfig, error) {
-	if err := mountConfigured("oem", cfg.Rancher.State.OemDev, cfg.Rancher.State.OemFsType, config.OemDir); err != nil {
-		log.Debugf("Not mounting OEM: %v", err)
+	if err := mountConfigured("oem", cfg.Rancher.State.OemDev, cfg.Rancher.State.OemFsType, config.OemDir, cfg.Rancher.State.OemMountOpt); err != nil {
+		log.Infof("Not mounting OEM: %v", err)
 	} else {
 		log.Infof("Mounted OEM: %s", cfg.Rancher.State.OemDev)
 	}
@@ -40,13 +46,13 @@
 
 	if rootDevice != "" && strings.Contains(rootDevice, "mmcblk") {
 		if err := util.Mount("/dev/mmcblk0p1", config.BootDir, "vfat", ""); err != nil {
-			log.Debugf("Not mounting BOOT: %v", err)
+			log.Infof("Not mounting BOOT: %v", err)
 			return cfg, nil
 		}
 	}
 
-	if err := mountConfigured("boot", cfg.Rancher.State.BootDev, cfg.Rancher.State.BootFsType, config.BootDir); err != nil {
-		log.Debugf("Not mounting BOOT: %v", err)
+	if err := mountConfigured("boot", cfg.Rancher.State.BootDev, cfg.Rancher.State.BootFsType, config.BootDir, cfg.Rancher.State.BootMountOpt); err != nil {
+		log.Infof("Not mounting BOOT: %v", err)
 	} else {
 		log.Infof("Mounted BOOT: %s", cfg.Rancher.State.BootDev)
 	}
@@ -54,17 +60,98 @@
 	return cfg, nil
 }
 
-func mountConfigured(display, dev, fsType, target string) error {
+
+func blkid2GetSiblings(dev string) (resLn string) {
+	cmd := exec.Command("/usr/bin/blkid2", "--get-siblings", dev)
+	cmd.Stderr = os.Stderr
+	out, err := cmd.Output()
+	if err != nil {
+		log.Infof("exec /usr/bin/blkid2 --get-siblings, failed.")
+		return
+	}
+	resLn = strings.TrimSuffix(string(out), "\n")
+	log.Infof("'/usr/bin/blkid2 --get-siblings %s' result, '%s'", dev, resLn)
+	return
+}
+
+
+func blkid2MatchStr(matchStr string) (deviceName, deviceType string, err error) {
+	if ! strings.Contains(matchStr, `="`) {
+		if strings.Contains(matchStr, `='`) {
+			s0 :=  strings.Split(matchStr, `='`)
+			matchStr = s0[0] + `="` + s0[1][0 : len(s0[1]) - 1] + `"`	
+		} else if strings.Contains(matchStr, `=\"`) {
+			s0 :=  strings.Split(matchStr, `=\"`)
+			matchStr = s0[0] + `="` + s0[1][0 : len(s0[1]) - 2] + `"`	
+		} else if strings.Contains(matchStr, `=\'`) {
+			s0 :=  strings.Split(matchStr, `='`)
+			matchStr = s0[0] + `="` + s0[1][0 : len(s0[1]) - 2] + `"`	
+		} else if strings.Contains(matchStr, "=") {
+			s0 := strings.Split(matchStr, "=")
+			matchStr = s0[0] + `="` + s0[1] + `"`
+		}
+	}
+	cmd := exec.Command("/usr/bin/blkid2")
+	cmd.Stderr = os.Stderr
+	out, err := cmd.Output()
+	if err != nil {
+		log.Infof("exec /usr/bin/blkid2, failed.")
+		return
+	}
+	r := bytes.NewReader(out)
+	s := bufio.NewScanner(r)
+	for s.Scan() {
+		line := s.Text()
+		if !strings.Contains(line, matchStr) {
+			continue
+		}
+		d := strings.Split(line, ":")
+		deviceName = d[0]
+
+		s1 := strings.Split(line, `TYPE="`)
+		s2 := strings.Split(s1[1], `"`)
+		deviceType = s2[0]
+		log.Infof("blkid2MatchStr: deviceName and deviceType detected.")
+		log.Infof(deviceName)
+		log.Infof(deviceType)
+		return
+	}
+	log.Infof("extract output from /usr/bin/blkid2, failed.")
+	log.Infof(matchStr)
+	log.Infof(string(out))
+	return
+}
+
+
+
+func _mountConfigured(display, dev, fsType, target, op string) error {
 	var err error
 
-	if dev == "" {
+	log.Infof("Mounting %s device %s to %s (option = '%s')", display, dev, target, op)
+	if err := util.Mount(dev, target, fsType, op) ; err != nil {
+		log.Infof("Mouting %s failed", dev)
+		return err
+	} else {
+		log.Infof("Mouted %s successful, dev)
 		return nil
 	}
+}
 
-	dev = util.ResolveDevice(dev)
+func mountConfigured(display, dname, fsType, target, option string) error {
+	var err error
+
+	if dname == "" {
+		return nil
+	}
+
+	dev, _, err := blkid2MatchStr(dname)
 	if dev == "" {
-		return fmt.Errorf("Could not resolve device %q", dev)
+		dev = util.ResolveDevice(dname)
+		if dev == "" {
+			return fmt.Errorf("Could not resolve device %q", dev)
+		}
 	}
+
 	if fsType == "auto" {
 		fsType, err = util.GetFsType(dev)
 	}
@@ -73,13 +160,62 @@
 		return err
 	}
 
-	log.Debugf("FsType has been set to %s", fsType)
-	log.Infof("Mounting %s device %s to %s", display, dev, target)
-	return util.Mount(dev, target, fsType, "")
+	log.Infof("FsType has been set to %s", fsType)
+	if fsType == "btrfs" {
+		opts := strings.Split(option, ",")
+		nodg := ""
+		fst := true
+		rw := 0
+		for _, s := range opts {
+			if s == "rw" {
+				rw = 1
+			}
+			if s != "degraded" {
+				if fst {
+					nodg = s
+				} else {
+					nodg += "," + s
+				}
+				fst = false
+			}
+		}
+		dg := "degraded"
+		if rw == 1 {
+			dg += ",rw"
+		}
+		if nodg != "" {
+			dg += "," + nodg
+		}
+		sibln := blkid2GetSiblings(dev)
+		if sibln != "" {
+			sibs := strings.Split(sibln, " ")
+			for _, s := range sibs {
+				nodg += ",device=" + s
+				dg += ",device=" + s
+			}
+		}
+		var ops[3]string
+		ops[0] = nodg
+		ops[1] = dg
+		ops[2] = option
+		ops[3] = ""
+		
+		for _, op := range opts {
+			for i := 0; i < 5; i++ {
+				if err2 := _mountConfigured(display, dev, target, fsType, op) ; err2 != nil {
+					time.Sleep(2 * time.Second)
+				} else {
+					return nil
+				}
+			}
+		}
+	} else {
+		return _mountConfigured(display, dev, target, fsType, option)
+	}
 }
 
 func mountState(cfg *config.CloudConfig) error {
-	return mountConfigured("state", cfg.Rancher.State.Dev, cfg.Rancher.State.FsType, config.StateDir)
+	return mountConfigured("state", cfg.Rancher.State.Dev, cfg.Rancher.State.FsType, config.StateDir, cfg.Rancher.State.MountOpt)
 }
 
 func tryMountState(cfg *config.CloudConfig) error {
@@ -119,6 +255,7 @@
 
 func MountStateAndBootstrap(cfg *config.CloudConfig) (*config.CloudConfig, error) {
 	var err error
+
 	cfg, ShouldSwitchRoot, err = tryMountStateAndBootstrap(cfg)
 
 	if err != nil {
diff -Naur '--exclude=.git' os.prev/pkg/init/prepare/prepare.go os.new/pkg/init/prepare/prepare.go
--- os.prev/pkg/init/prepare/prepare.go	2024-02-15 15:45:46.760000000 +0900
+++ os.new/pkg/init/prepare/prepare.go	2024-02-19 10:29:20.982499700 +0900
@@ -3,6 +3,7 @@
 import (
 	"os"
 	"strings"
+	"os/exec"
 
 	"github.com/burmilla/os/config"
 	"github.com/burmilla/os/pkg/dfs"
@@ -37,5 +38,15 @@
 		log.SetLevel(log.InfoLevel)
 	}
 
+	if cfg.Rancher.State.useUdev {
+		log.Infof("executing /usr/bin/after_save_cmd_line")
+		cmd := exec.Command("/usr/bin/after_save_cmd_line")
+		cmd.Stderr = os.Stderr
+		_, errb := cmd.Output()
+		if errb != nil {
+			log.Infof("exec /usr/bin/after_save_cmd_line failed.")
+		}
+	}
+
 	return cfg, nil
 }
diff -Naur '--exclude=.git' os.prev/pkg/init/switchroot/switchroot.go os.new/pkg/init/switchroot/switchroot.go
--- os.prev/pkg/init/switchroot/switchroot.go	2024-02-15 15:45:46.760000000 +0900
+++ os.new/pkg/init/switchroot/switchroot.go	2024-02-19 11:11:28.932499700 +0900
@@ -4,9 +4,11 @@
 	"fmt"
 	"io/ioutil"
 	"os"
+	"os/exec"
 	"path"
 	"strings"
 	"syscall"
+	"path/filepath"
 
 	"github.com/burmilla/os/config"
 	"github.com/burmilla/os/pkg/dfs"
@@ -20,7 +22,7 @@
 	if !fsmount.ShouldSwitchRoot {
 		return cfg, nil
 	}
-	log.Debugf("Switching to new root at %s %s", config.StateDir, cfg.Rancher.State.Directory)
+	log.Infof("Switching to new root at %s %s", config.StateDir, cfg.Rancher.State.Directory)
 	if err := switchRoot(config.StateDir, cfg.Rancher.State.Directory, cfg.Rancher.RmUsr); err != nil {
 		return cfg, err
 	}
@@ -28,7 +30,7 @@
 }
 
 func cleanupTarget(rootfs, targetUsr, usr, usrVer, tmpDir string) (bool, error) {
-	log.Debugf("Deleting %s", targetUsr)
+	log.Infof("Deleting %s", targetUsr)
 	if err := os.Remove(targetUsr); err != nil && !os.IsNotExist(err) {
 		log.Errorf("Failed to delete %s, possibly invalid BurmillaOS state partition: %v", targetUsr, err)
 		return false, err
@@ -38,7 +40,7 @@
 		return false, err
 	}
 
-	log.Debugf("Deleting %s", tmpDir)
+	log.Infof("Deleting %s", tmpDir)
 	if err := os.RemoveAll(tmpDir); err != nil {
 		// Don't care if this fails
 		log.Errorf("Failed to cleanup temp directory %s: %v", tmpDir, err)
@@ -69,7 +71,7 @@
 		return err
 	}
 
-	log.Debugf("Creating temp dir directory %s", tmpDir)
+	log.Infof("Creating temp dir directory %s", tmpDir)
 	if err := os.MkdirAll(tmpDir, 0755); err != nil {
 		return err
 	}
@@ -79,13 +81,13 @@
 		return err
 	}
 
-	log.Debugf("Copying to temp dir %s", usrVerTmp)
+	log.Infof("Copying to temp dir %s", usrVerTmp)
 
 	if err := archive.CopyWithTar("/usr", usrVerTmp); err != nil {
 		return err
 	}
 
-	log.Debugf("Renaming %s => %s", usrVerTmp, usr)
+	log.Infof("Renaming %s => %s", usrVerTmp, usr)
 	if err := os.Rename(usrVerTmp, usr); err != nil {
 		return err
 	}
@@ -99,11 +101,11 @@
 		filename := path.Join("/", file.Name())
 
 		if filename == rootfs || strings.HasPrefix(rootfs, filename+"/") {
-			log.Debugf("Skipping Deleting %s", filename)
+			log.Infof("Skipping Deleting %s", filename)
 			continue
 		}
 
-		log.Debugf("Deleting %s", filename)
+		log.Infof("Deleting %s", filename)
 		if err := os.RemoveAll(filename); err != nil {
 			return err
 		}
@@ -113,8 +115,19 @@
 }
 
 func switchRoot(rootfs, subdir string, rmUsr bool) error {
+	filepath.Walk("/", func(path string, info os.FileInfo, err error) error {
+		if err != nil {
+			return err
+		}
+		if info.IsDir() {
+			log.Infof("\n%s\n", path + "/")
+		} else {
+			log.Infof("\n%s\n", path)
+		}
+		return nil
+	})
 	if err := syscall.Unmount(config.OemDir, 0); err != nil {
-		log.Debugf("Not umounting OEM: %v", err)
+		log.Infof("Not umounting OEM: %v", err)
 	}
 
 	if subdir != "" {
@@ -126,7 +139,7 @@
 			}
 		}
 
-		log.Debugf("Bind mounting mount %s to %s", fullRootfs, rootfs)
+		log.Infof("Bind mounting mount %s to %s", fullRootfs, rootfs)
 		if err := syscall.Mount(fullRootfs, rootfs, "", syscall.MS_BIND, ""); err != nil {
 			log.Errorf("Failed to bind mount subdir for %s: %v", fullRootfs, err)
 			return err
@@ -134,7 +147,7 @@
 	}
 
 	for _, i := range []string{"/dev", "/sys", "/proc", "/run"} {
-		log.Debugf("Moving mount %s to %s", i, path.Join(rootfs, i))
+		log.Infof("Moving mount %s to %s", i, path.Join(rootfs, i))
 		if err := os.MkdirAll(path.Join(rootfs, i), 0755); err != nil {
 			return err
 		}
@@ -147,17 +160,37 @@
 		return err
 	}
 
-	log.Debugf("chdir %s", rootfs)
+	log.Infof("chdir %s", rootfs)
 	if err := syscall.Chdir(rootfs); err != nil {
 		return err
 	}
+	filepath.Walk("/", func(path string, info os.FileInfo, err error) error {
+		if err != nil {
+			return err
+		}
+		if info.IsDir() {
+			log.Infof("\n%s\n", path + "/")
+		} else {
+			log.Infof("\n%s\n", path)
+		}
+		return nil
+	})
+
+	log.Infof("executing before_switch_root")
+	cmd := exec.Command("/usr/bin/before_switch_root")
+	cmd.Stderr = os.Stderr
+	_, errb := cmd.Output()
+	if errb != nil {
+		log.Infof("exec /usr/bin/before_switch_root failed.")
+	}
 
-	log.Debugf("mount MS_MOVE %s", rootfs)
+	log.Infof("mount MS_MOVE %s", rootfs)
 	if err := syscall.Mount(rootfs, "/", "", syscall.MS_MOVE, ""); err != nil {
 		return err
 	}
 
 	log.Debug("chroot .")
+
 	if err := syscall.Chroot("."); err != nil {
 		return err
 	}
@@ -167,7 +200,7 @@
 		return err
 	}
 
-	log.Debugf("Successfully moved to new root at %s", path.Join(rootfs, subdir))
+	log.Infof("Successfully moved to new root at %s", path.Join(rootfs, subdir))
 	os.Unsetenv("DOCKER_RAMDISK")
 
 	return nil
diff -Naur '--exclude=.git' os.prev/pkg/sysinit/sysinit.go os.new/pkg/sysinit/sysinit.go
--- os.prev/pkg/sysinit/sysinit.go	2024-02-15 15:45:46.760000000 +0900
+++ os.new/pkg/sysinit/sysinit.go	2024-02-17 15:16:56.553369600 +0900
@@ -93,6 +93,14 @@
 }
 
 func SysInit() error {
+	log.Infof("executing /usr/bin/before_sysinit")
+	cmd := exec.Command("/usr/bin/before_sysinit")
+	cmd.Stderr = os.Stderr
+	_, errb := cmd.Output()
+	if errb != nil {
+		log.Infof("exec /usr/bin/before_sysinit failed.")
+	}
+
 	cfg := config.LoadConfig()
 
 	if err := control.PreloadImages(docker.NewSystemClient, systemImagesPreloadDirectory); err != nil {
diff -Naur '--exclude=.git' os.prev/scripts/version os.new/scripts/version
--- os.prev/scripts/version	2024-02-15 15:45:46.770000000 +0900
+++ os.new/scripts/version	2024-02-15 15:47:10.100000000 +0900
@@ -1,18 +1,26 @@
 #!/bin/bash
 
-if [ -n "$(git status --porcelain --untracked-files=no)" ]; then
-    DIRTY="-dirty"
-fi
+#if [ -n "$(git status --porcelain --untracked-files=no)" ]; then
+#    DIRTY="-dirty"
+#fi
 
 COMMIT=$(git rev-parse --short HEAD)
 GIT_TAG=$(git tag -l --contains HEAD | head -n 1)
 
-if [ -z "$VERSION" ]; then
-    if [[ -z "$DIRTY" && -n "$GIT_TAG" ]]; then
-        VERSION=$GIT_TAG
-    else
-        VERSION="${COMMIT}${DIRTY}"
-    fi
+#if [ -z "$VERSION" ]; then
+#    if [[ -z "$DIRTY" && -n "$GIT_TAG" ]]; then
+#        VERSION=$GIT_TAG-btrfs-0.9
+#    else
+#        VERSION="${COMMIT}${DIRTY}"
+#    fi
+#fi
+
+if [ ! -e ../.git/packed-refs ]; then
+	VERSION=`cat /tmp/version.patched`
+else
+	TTAG=`tail -1 ../.git/packed-refs`
+	VERSION=${TTAG##*/}-btrfs-__PVER__
+	echo -n $VERSION > /tmp/version.patched
 fi
 
 INITRD=initrd-${VERSION}

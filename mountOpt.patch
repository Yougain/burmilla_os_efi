diff -Naur '--exclude=.git' os.prev/cmd/control/autologin.go os.new/cmd/control/autologin.go
--- os.prev/cmd/control/autologin.go	2024-03-14 20:29:45.937485300 +0900
+++ os.new/cmd/control/autologin.go	2024-05-14 20:04:27.397314900 +0900
@@ -75,9 +75,9 @@
 	os.Setenv("TERM", "linux")
 
 	// Causes all sorts of issues
-	//return syscall.Exec(loginBinPath, args, os.Environ())
+	//return syscall.Exec(loginBinPath, args, config.Environ())
 	cmd = exec.Command(loginBinPath, args...)
-	cmd.Env = os.Environ()
+	cmd.Env = config.Environ()
 
 	cmd.Stderr = os.Stderr
 	cmd.Stdout = os.Stdout
diff -Naur '--exclude=.git' os.prev/cmd/control/config.go os.new/cmd/control/config.go
--- os.prev/cmd/control/config.go	2024-03-14 20:29:45.937485300 +0900
+++ os.new/cmd/control/config.go	2024-05-14 20:04:27.397314900 +0900
@@ -143,7 +143,7 @@
 		log.Fatal("Could not read from stdin")
 	}
 	tpl := template.Must(template.New("osconfig").Parse(string(bytes)))
-	return tpl.Execute(out, env2map(os.Environ()))
+	return tpl.Execute(out, env2map(config.Environ()))
 }
 
 func env2map(env []string) map[string]string {
diff -Naur '--exclude=.git' os.prev/cmd/control/console_init.go os.new/cmd/control/console_init.go
--- os.prev/cmd/control/console_init.go	2024-03-14 20:29:45.937485300 +0900
+++ os.new/cmd/control/console_init.go	2024-05-23 14:28:06.747889400 +0900
@@ -11,6 +11,7 @@
 	"strings"
 	"syscall"
 	"text/template"
+	"net"
 
 	"github.com/burmilla/os/cmd/cloudinitexecute"
 	"github.com/burmilla/os/config"
@@ -259,6 +260,72 @@
 	if err := cmd.Run(); err != nil {
 		log.Error(err)
 	}
+	
+	cmd = exec.Command("stat", "-f", "-c", "%T", "/opt")
+	out, errb := cmd.Output()
+	if errb != nil {
+		log.Error("exec stat -f -c %T /opt, failed.")
+	}else{
+		if strings.Index(string(out), "ramfs") != -1 {
+			file, err := os.OpenFile("/etc/issue", os.O_APPEND|os.O_WRONLY, 0600)
+			var ip net.IP
+			ips := ""
+			if err != nil {
+				log.Error(err)
+			} else {
+				defer file.Close()
+				interfaces, err := net.Interfaces()
+				if err != nil {
+					log.Error(err)
+					return err
+				}
+
+				for _, i := range interfaces {
+					addrs, err := i.Addrs()
+					if err != nil {
+						log.Error(err)
+						continue
+					}
+					if strings.HasPrefix(i.Name, "docker") {
+						continue
+					}
+					if i.Name == "lo" {
+						continue
+					}
+
+					for _, addr := range addrs {
+						switch v := addr.(type) {
+						case *net.IPNet:
+							ip = v.IP
+						case *net.IPAddr:
+							ip = v.IP
+						}
+
+						// 最初のIPv4アドレスのみを格納
+						if ip.To4() != nil {
+							ips = ip.String()
+							break
+						}
+					}
+				}				
+				if ips != "" {
+					_, err = file.WriteString(`
+For installation, please execute:
+  wget http://` + ips + `/install.sh -q -O - \| bash -s NAME IP SPORT DEV KVARS...
+    NAME     : New server name, ex. 'serv1.foo.com'
+    IP       : New fixed IPv4 address for the system, ex. '10.1.1.1'
+    SPORT    : SSH port number for the system, ex. '20022'
+    DEV      : Device name on which the system is installed, ex. '/dev/sdc'
+    KVARS... : Extra kernel environmental variables, ex. 'ROS_LOG_FORMAT=non-json ...'
+from your terminal.
+` )
+				}
+				if err != nil {
+					log.Error(err)
+ 				}
+ 			}
+		}
+	}
 
 	cloudinitexecute.ApplyConsole(cfg)
 
@@ -293,7 +360,7 @@
 		return err
 	}
 
-	return syscall.Exec(respawnBinPath, []string{"respawn", "-f", "/etc/respawn.conf"}, os.Environ())
+	return syscall.Exec(respawnBinPath, []string{"respawn", "-f", "/etc/respawn.conf"}, config.Environ())
 }
 
 func generateRespawnConf(cmdline, user string, sshd, recovery bool) string {
diff -Naur '--exclude=.git' os.prev/cmd/control/docker_init.go os.new/cmd/control/docker_init.go
--- os.prev/cmd/control/docker_init.go	2024-03-14 20:29:45.937485300 +0900
+++ os.new/cmd/control/docker_init.go	2024-05-14 20:04:27.397314900 +0900
@@ -112,5 +112,5 @@
 		log.Error(err)
 	}
 
-	return syscall.Exec("/bin/bash", args, os.Environ())
+	return syscall.Exec("/bin/bash", args, config.Environ())
 }
diff -Naur '--exclude=.git' os.prev/cmd/control/entrypoint.go os.new/cmd/control/entrypoint.go
--- os.prev/cmd/control/entrypoint.go	2024-03-14 20:29:45.937485300 +0900
+++ os.new/cmd/control/entrypoint.go	2024-05-14 20:04:27.397314900 +0900
@@ -55,8 +55,8 @@
 	if err != nil {
 		return err
 	}
-
-	return syscall.Exec(binary, os.Args[2:], os.Environ())
+	
+	return syscall.Exec(binary, os.Args[2:], config.Environ())
 }
 
 func writeFiles(cfg *config.CloudConfig) error {
diff -Naur '--exclude=.git' os.prev/cmd/control/env.go os.new/cmd/control/env.go
--- os.prev/cmd/control/env.go	2024-03-14 20:29:45.937485300 +0900
+++ os.new/cmd/control/env.go	2024-05-14 20:04:27.397314900 +0900
@@ -2,7 +2,6 @@
 
 import (
 	"log"
-	"os"
 	"os/exec"
 	"syscall"
 
@@ -19,7 +18,7 @@
 	if len(args) == 0 {
 		return nil
 	}
-	osEnv := os.Environ()
+	osEnv := config.Environ()
 
 	envMap := make(map[string]string, len(cfg.Rancher.Environment)+len(osEnv))
 	for k, v := range cfg.Rancher.Environment {
diff -Naur '--exclude=.git' os.prev/cmd/control/install.go os.new/cmd/control/install.go
--- os.prev/cmd/control/install.go	2024-03-14 20:29:45.937485300 +0900
+++ os.new/cmd/control/install.go	2024-05-14 20:04:27.397314900 +0900
@@ -201,6 +201,11 @@
 func runInstall(image, installType, cloudConfig, device, partition, statedir, kappend string, force, kexec, isoinstallerloaded, debug bool, savedImages []string) error {
 	fmt.Printf("Installing from %s\n", image)
 
+	if os.Getenv("ROS_BTRFS_WRAPPER") == "" {
+		log.Errorf("You cannot execute ros install or upgrade command directly.")
+		fmt.Println("You cannot execute ros install or upgrade command directly, terminate the task.")
+		os.Exit(1)
+	}
 	if !force {
 		if util.IsRunningInTty() && !yes("Continue") {
 			log.Infof("Not continuing with installation due to user not saying 'yes'")
@@ -223,14 +228,14 @@
 			if err = mountBootIso(deviceName, deviceType); err != nil {
 				log.Debugf("Failed to mountBootIso: %v", err)
 			} else {
-				log.Infof("trying to load /bootiso/rancheros/installer.tar.gz")
+				log.Infof("trying to load /bootiso/rancheros/fullinstaller.tar.gz")
 				if _, err := os.Stat("/bootiso/rancheros/"); err == nil {
-					cmd := exec.Command("system-docker", "load", "-i", "/bootiso/rancheros/installer.tar.gz")
+					cmd := exec.Command("system-docker", "load", "-i", "/bootiso/rancheros/fullinstaller.tar.gz")
 					cmd.Stdout, cmd.Stderr = os.Stdout, os.Stderr
 					if err := cmd.Run(); err != nil {
 						log.Infof("failed to load images from /bootiso/rancheros: %v", err)
 					} else {
-						log.Infof("Loaded images from /bootiso/rancheros/installer.tar.gz")
+						log.Infof("Loaded images from /bootiso/rancheros/fullinstaller.tar.gz")
 
 						//TODO: add if os-installer:latest exists - we might have loaded a full installer?
 						useIso = true
@@ -247,11 +252,14 @@
 			}
 
 			log.Infof("starting installer container for %s (new)", image)
+			ros_btrfs_wrapper := os.Getenv("ROS_BTRFS_WRAPPER")
 			installerCmd := []string{
 				"run", "--rm", "--net=host", "--privileged",
 				// bind mount host fs to access its ros, vmlinuz, initrd and /dev (udev isn't running in container)
 				"-v", "/:/host",
 				"--volumes-from=all-volumes",
+				"-e",
+				"ROS_BTRFS_WRAPPER=" + ros_btrfs_wrapper,
 				image,
 				//				"install",
 				"-t", installType,
diff -Naur '--exclude=.git' os.prev/cmd/control/recovery_init.go os.new/cmd/control/recovery_init.go
--- os.prev/cmd/control/recovery_init.go	2024-03-14 20:29:45.937485300 +0900
+++ os.new/cmd/control/recovery_init.go	2024-05-14 20:04:27.397314900 +0900
@@ -1,11 +1,11 @@
 package control
 
 import (
-	"os"
 	"os/exec"
 	"syscall"
 
 	"github.com/burmilla/os/pkg/log"
+	"github.com/burmilla/os/config"
 
 	"github.com/codegangsta/cli"
 )
@@ -20,5 +20,5 @@
 		return err
 	}
 
-	return syscall.Exec(respawnBinPath, []string{"respawn", "-f", "/etc/respawn.conf"}, os.Environ())
+	return syscall.Exec(respawnBinPath, []string{"respawn", "-f", "/etc/respawn.conf"}, config.Environ())
 }
diff -Naur '--exclude=.git' os.prev/cmd/control/user_docker.go os.new/cmd/control/user_docker.go
--- os.prev/cmd/control/user_docker.go	2024-03-14 20:29:45.937485300 +0900
+++ os.new/cmd/control/user_docker.go	2024-05-14 20:04:27.407314900 +0900
@@ -193,7 +193,7 @@
 	cmd = append(cmd, args...)
 	log.Infof("Running %v", cmd)
 
-	return syscall.Exec("/usr/bin/system-docker-runc", cmd, os.Environ())
+	return syscall.Exec("/usr/bin/system-docker-runc", cmd, config.Environ())
 }
 
 func waitForPid(service string, project *project.Project) (int, error) {
diff -Naur '--exclude=.git' os.prev/cmd/init/init.go os.new/cmd/init/init.go
--- os.prev/cmd/init/init.go	2024-03-14 20:29:45.937485300 +0900
+++ os.new/cmd/init/init.go	2024-05-14 20:04:27.407314900 +0900
@@ -5,7 +5,8 @@
 
 import (
 	"fmt"
-
+	"os/exec"
+	"time"
 	"github.com/burmilla/os/config"
 	"github.com/burmilla/os/pkg/dfs"
 	"github.com/burmilla/os/pkg/init/b2d"
@@ -38,6 +39,14 @@
 
 	if err := RunInit(); err != nil {
 		log.Fatal(err)
+		dmsg, errb := exec.Command("bash", "-c", "dmesg | tail -10").Output()
+		if errb == nil {
+			log.Warnf("%s", string(dmsg))
+		}
+		log.Warnf("Continue by chrooting.", err)
+		if errb != nil {
+			log.Warnf("cannot exec dmesg (Error:%v)", errb)
+		}
 	}
 }
 
@@ -79,7 +88,9 @@
 	log.Info("Launching System Docker")
 	_, err = dfs.LaunchDocker(launchConfig, config.SystemDockerBin, args...)
 	if err != nil {
+		time.Sleep(3 * time.Second)
 		log.Errorf("Error Launching System Docker: %s", err)
+		time.Sleep(3 * time.Second)
 		recovery.Recovery(err)
 		return err
 	}
diff -Naur '--exclude=.git' os.prev/cmd/power/shutdown.go os.new/cmd/power/shutdown.go
--- os.prev/cmd/power/shutdown.go	2024-03-14 20:29:45.937485300 +0900
+++ os.new/cmd/power/shutdown.go	2024-05-22 14:31:13.031263300 +0900
@@ -27,6 +27,9 @@
 func Shutdown() {
 	log.InitLogger()
 	app := cli.NewApp()
+	
+	cmd := exec.Command("/opt/rancher/bin/shutdown.sh")
+	cmd.Run()
 
 	app.Name = filepath.Base(os.Args[0])
 	app.Usage = fmt.Sprintf("%s BurmillaOS\nbuilt: %s", app.Name, config.BuildDate)
diff -Naur '--exclude=.git' os.prev/config/config.go os.new/config/config.go
--- os.prev/config/config.go	2024-03-14 20:29:45.957485300 +0900
+++ os.new/config/config.go	2024-05-14 20:04:27.407314900 +0900
@@ -2,13 +2,17 @@
 
 import (
 	"io/ioutil"
+	"os"
 	"strings"
 
+	"github.com/burmilla/os/pkg/log"
 	"github.com/burmilla/os/config/cmdline"
 	"github.com/burmilla/os/pkg/util"
 	yaml "github.com/cloudfoundry-incubator/candiedyaml"
 )
 
+var nenv []string
+
 const Banner = `
     ____                       _ _ _        ____   _____
    |  _ \\                     (_) | |      / __ \\ / ____|
@@ -94,3 +98,31 @@
 	elem := strings.Split(string(b), " ")
 	return elem[2]
 }
+
+
+func Environ() []string {
+	tz := ""
+	if os.Getenv("TZ") == "" {
+		log.Debug("Trying read /proc/cmdline")
+		cmdline, err := ReadAll("/proc/cmdline")
+		if err == nil {
+			log.Debugf("/proc/cmdline = $s", cmdline)
+			ti := strings.Index(cmdline, " TZ=")
+			if ti != -1 {
+				tw := strings.Index(cmdline[ti + 4:], " ")
+				if tw != -1 {
+					tz = cmdline[ti + 4:ti + 4 + tw]
+					log.Debugf("TZ = %s", tz)
+				}
+			}else{
+				log.Debugf("cannot find 'TZ=' in /proc/cmdline")
+			}
+		}else{
+			log.Debugf("cannot read /proc/cmdline")
+		}
+		nenv = append(os.Environ(), "TZ=" + tz)
+	}else{
+		nenv = os.Environ()
+	}
+	return nenv
+}
diff -Naur '--exclude=.git' os.prev/config/docker_config.go os.new/config/docker_config.go
--- os.prev/config/docker_config.go	2024-03-14 20:29:45.957485300 +0900
+++ os.new/config/docker_config.go	2024-05-14 20:04:27.407314900 +0900
@@ -2,9 +2,13 @@
 
 import (
 	"fmt"
+	"io"
 	"os"
+	"strings"
+	"bytes"
 
 	"github.com/fatih/structs"
+	"github.com/burmilla/os/pkg/log"
 )
 
 func (d *DockerConfig) FullArgs() []string {
@@ -23,8 +27,53 @@
 	return args
 }
 
+
+func ReadAll(filename string) (string, error) {
+	file, err := os.Open(filename)
+	if err != nil {
+		return "", err
+	}
+	defer file.Close()
+
+	var buffer bytes.Buffer
+	_, err = io.Copy(&buffer, file)
+	if err != nil {
+		return "", err
+	}
+
+	return buffer.String(), nil
+}
+
+
+func environ() []string {
+	tz := ""
+	if os.Getenv("TZ") == "" {
+		log.Debug("Trying read /proc/cmdline")
+		cmdline, err := ReadAll("/proc/cmdline")
+		if err == nil {
+			log.Debugf("/proc/cmdline = $s", cmdline)
+			ti := strings.Index(cmdline, " TZ=")
+			if ti != -1 {
+				tw := strings.Index(cmdline[ti + 4:], " ")
+				if tw != -1 {
+					tz = cmdline[ti + 4:ti + 4 + tw]
+					log.Debugf("TZ = %s", tz)
+				}
+			}else{
+				log.Debugf("cannot find 'TZ=' in /proc/cmdline")
+			}
+		}else{
+			log.Debugf("cannot read /proc/cmdline")
+		}
+		nenv = append(os.Environ(), "TZ=" + tz)
+	}else{
+		nenv = os.Environ()
+	}
+	return nenv
+}
+
 func (d *DockerConfig) AppendEnv() []string {
-	return append(os.Environ(), d.Environment...)
+	return append(environ(), d.Environment...)
 }
 
 func generateEngineOptsSlice(opts EngineOpts) []string {
diff -Naur '--exclude=.git' os.prev/config/types.go os.new/config/types.go
--- os.prev/config/types.go	2024-03-14 20:29:45.957485300 +0900
+++ os.new/config/types.go	2024-05-14 20:04:27.407314900 +0900
@@ -210,6 +210,7 @@
 type StateConfig struct {
 	Directory  string   `yaml:"directory,omitempty"`
 	FsType     string   `yaml:"fstype,omitempty"`
+	MountOpt     string   `yaml:"mountopt,omitempty"`
 	Dev        string   `yaml:"dev,omitempty"`
 	Wait       bool     `yaml:"wait,omitempty"`
 	Required   bool     `yaml:"required,omitempty"`
@@ -220,8 +221,10 @@
 	Rngd       bool     `yaml:"rngd,omitempty"`
 	Script     string   `yaml:"script,omitempty"`
 	OemFsType  string   `yaml:"oem_fstype,omitempty"`
+	OemMountOpt  string   `yaml:"oem_mountopt,omitempty"`
 	OemDev     string   `yaml:"oem_dev,omitempty"`
 	BootFsType string   `yaml:"boot_fstype,omitempty"`
+	BootMountOpt string   `yaml:"boot_mountopt,omitempty"`
 	BootDev    string   `yaml:"boot_dev,omitempty"`
 }
 
diff -Naur '--exclude=.git' os.prev/images/02-console/Dockerfile os.new/images/02-console/Dockerfile
--- os.prev/images/02-console/Dockerfile	2024-03-14 20:29:45.967485300 +0900
+++ os.new/images/02-console/Dockerfile	2024-05-23 10:17:33.147889400 +0900
@@ -34,7 +34,9 @@
     && addgroup --gid 1200 user-docker \
     && adduser --system -u 1200 --gid 1200 --disabled-login --no-create-home user-docker \
     && echo 'user-docker:100000:65536' > /etc/subuid \
-    && echo 'user-docker:100000:65536' > /etc/subgid
+    && echo 'user-docker:100000:65536' > /etc/subgid \
+    && rm -f /etc/localtime \
+    && cp /usr/share/zoneinfo/Etc/UTC /etc/localtime
 
 COPY build/iscsid.conf /etc/iscsi/
 
diff -Naur '--exclude=.git' os.prev/install_burmillaos_on_btrfs os.new/install_burmillaos_on_btrfs
--- os.prev/install_burmillaos_on_btrfs	1970-01-01 09:00:00.000000000 +0900
+++ os.new/install_burmillaos_on_btrfs	2024-05-14 20:04:27.407314900 +0900
@@ -0,0 +1 @@
+
diff -Naur '--exclude=.git' os.prev/main.go os.new/main.go
--- os.prev/main.go	2024-03-14 20:29:45.967485300 +0900
+++ os.new/main.go	2024-05-14 20:04:27.407314900 +0900
@@ -3,6 +3,11 @@
 import (
 	"fmt"
 	"os"
+    "strconv"
+    "time"
+    "io"
+	"strings"
+	"bytes"
 
 	"github.com/burmilla/os/cmd/cloudinitexecute"
 	"github.com/burmilla/os/cmd/cloudinitsave"
@@ -38,7 +43,46 @@
 	"shutdown": power.Shutdown,
 }
 
+
+func ReadAll(filename string) (string, error) {
+	file, err := os.Open(filename)
+	if err != nil {
+		return "", err
+	}
+	defer file.Close()
+
+	var buffer bytes.Buffer
+	_, err = io.Copy(&buffer, file)
+	if err != nil {
+		return "", err
+	}
+
+	return buffer.String(), nil
+}
+
+
 func main() {
+	tzs := os.Getenv("TZS")
+	base := 0
+	if tzs != "" {
+		base, _ = strconv.Atoi(tzs)
+	}
+	if base == 0 {
+		cmdline, err := ReadAll("/proc/cmdline")
+		if err == nil {
+			ti := strings.Index(cmdline, " TZS=")
+			if ti != -1 {
+				tw := strings.Index(cmdline[ti + 5:], " ")
+				if tw != -1 {
+					base, _ = strconv.Atoi(cmdline[ti + 5:ti + 5 + tw])
+				}
+			}
+		}
+	}
+	if base != 0 {
+		time.FixedZone("LOCAL", base)
+	}
+
 	if 0 == 1 {
 		// TODO: move this into a "dev/debug +build"
 		fmt.Fprintf(os.Stderr, "ros main(%s) ppid:%d - print to stdio\n", os.Args[0], os.Getppid())
diff -Naur '--exclude=.git' os.prev/os-config.tpl.yml os.new/os-config.tpl.yml
--- os.prev/os-config.tpl.yml	2024-03-14 20:29:45.967485300 +0900
+++ os.new/os-config.tpl.yml	2024-05-22 12:36:36.901263300 +0900
@@ -147,10 +147,10 @@
       - /usr/share/ros:/usr/share/ros
       - /var/lib/boot2docker:/var/lib/boot2docker
       - /var/lib/rancher/cache:/var/lib/rancher/cache
-      - /var/lib/rancher/conf:/var/lib/rancher/conf
+      - /usr/share/ros/.oem_link/var/lib/rancher/conf:/var/lib/rancher/conf
       - /var/lib/rancher:/var/lib/rancher
       - /var/lib/waagent:/var/lib/waagent
-      - /var/log:/var/log
+      - /usr/share/ros/.oem_link/var/log:/var/log
       - /var/run:/var/run
     container-data-volumes:
       image: {{.OS_REPO}}/os-base:{{.VERSION}}{{.SUFFIX}}
@@ -163,8 +163,8 @@
       privileged: true
       read_only: true
       volumes:
-      - /var/lib/user-docker:/var/lib/docker
-      - /var/lib/m-user-docker:/var/lib/m-user-docker
+      - /usr/share/ros/.oem_link/var/lib/user-docker:/var/lib/docker
+      - /usr/share/ros/.oem_link/var/lib/m-user-docker:/var/lib/m-user-docker
     user-volumes:
       image: {{.OS_REPO}}/os-base:{{.VERSION}}{{.SUFFIX}}
       command: echo
@@ -176,9 +176,9 @@
       privileged: true
       read_only: true
       volumes:
-      - /home:/home
-      - /opt:/opt
-      - /var/lib/kubelet:/var/lib/kubelet
+      - /usr/share/ros/.oem_link/home:/home
+      - /usr/share/ros/.oem_link/opt:/opt
+      - /usr/share/ros/.oem_link/var/lib/kubelet:/var/lib/kubelet
     media-volumes:
       image: {{.OS_REPO}}/os-base:{{.VERSION}}{{.SUFFIX}}
       command: echo
@@ -260,6 +260,10 @@
       volumes:
       - /media:/media:shared
       - /mnt:/mnt:shared
+      - /boot:/boot
+      - /usr/share/ros/.oem_link/etc/localtime:/etc/localtime
+      - /usr/share/ros/.oem_link/etc/ssh:/etc/ssh
+      - /usr/share/ros/.oem_link/etc/profile.d/timezone.sh:/etc/profile.d/timezone.sh
     logrotate:
       image: {{.OS_REPO}}/os-logrotate:{{.VERSION}}{{.SUFFIX}}
       command: /usr/sbin/logrotate -v /etc/logrotate.conf
diff -Naur '--exclude=.git' os.prev/pkg/dfs/scratch.go os.new/pkg/dfs/scratch.go
--- os.prev/pkg/dfs/scratch.go	2024-03-14 20:29:45.967485300 +0900
+++ os.new/pkg/dfs/scratch.go	2024-05-14 20:04:27.407314900 +0900
@@ -11,6 +11,7 @@
 	"strings"
 	"syscall"
 
+	"github.com/burmilla/os/config"
 	"github.com/burmilla/os/config/cmdline"
 	"github.com/burmilla/os/pkg/init/one"
 	"github.com/burmilla/os/pkg/log"
@@ -172,20 +173,20 @@
 	return nil
 }
 
-func execDocker(config *Config, docker, cmd string, args []string) (*exec.Cmd, error) {
+func execDocker(config_ *Config, docker, cmd string, args []string) (*exec.Cmd, error) {
 	if len(args) > 0 && args[0] == "docker" {
 		args = args[1:]
 	}
 	log.Debugf("Launching Docker %s %s %v", docker, cmd, args)
 
-	env := os.Environ()
-	if len(config.Environment) != 0 {
-		env = append(env, config.Environment...)
+	env := config.Environ()
+	if len(config_.Environment) != 0 {
+		env = append(env, config_.Environment...)
 	}
 
-	if config.Fork {
+	if config_.Fork {
 		cmd := exec.Command(docker, args...)
-		if !config.NoLog {
+		if !config_.NoLog {
 			cmd.Stdout = os.Stdout
 			cmd.Stderr = os.Stderr
 		}
@@ -194,7 +195,7 @@
 		if err != nil {
 			return cmd, err
 		}
-		if config.PidOne {
+		if config_.PidOne {
 			one.PidOne()
 		}
 		return cmd, err
diff -Naur '--exclude=.git' os.prev/pkg/init/configfiles/configfiles.go os.new/pkg/init/configfiles/configfiles.go
--- os.prev/pkg/init/configfiles/configfiles.go	2024-03-14 20:29:45.967485300 +0900
+++ os.new/pkg/init/configfiles/configfiles.go	2024-05-14 20:04:27.407314900 +0900
@@ -55,6 +55,7 @@
 			ConfigFiles[name] = content
 		}
 	}
+	log.UntilLogWritable("/var/log/boot/init.log")
 	return cfg, nil
 }
 
diff -Naur '--exclude=.git' os.prev/pkg/init/fsmount/fsmount.go os.new/pkg/init/fsmount/fsmount.go
--- os.prev/pkg/init/fsmount/fsmount.go	2024-03-14 20:29:45.967485300 +0900
+++ os.new/pkg/init/fsmount/fsmount.go	2024-05-22 22:27:34.341263300 +0900
@@ -4,6 +4,8 @@
 	"fmt"
 	"strings"
 	"syscall"
+	"os"
+	"os/exec"
 
 	"github.com/burmilla/os/config"
 	"github.com/burmilla/os/config/cmdline"
@@ -18,16 +20,16 @@
 )
 
 var (
+	MountDegraded = false
 	ShouldSwitchRoot bool
 )
 
 func MountOem(cfg *config.CloudConfig) (*config.CloudConfig, error) {
-	if err := mountConfigured("oem", cfg.Rancher.State.OemDev, cfg.Rancher.State.OemFsType, config.OemDir); err != nil {
+	if err := mountConfigured("oem", cfg.Rancher.State.OemDev, cfg.Rancher.State.OemFsType, config.OemDir, cfg.Rancher.State.OemMountOpt); err != nil {
 		log.Debugf("Not mounting OEM: %v", err)
 	} else {
 		log.Infof("Mounted OEM: %s", cfg.Rancher.State.OemDev)
 	}
-
 	return cfg, nil
 }
 
@@ -45,7 +47,7 @@
 		}
 	}
 
-	if err := mountConfigured("boot", cfg.Rancher.State.BootDev, cfg.Rancher.State.BootFsType, config.BootDir); err != nil {
+	if err := mountConfigured("boot", cfg.Rancher.State.BootDev, cfg.Rancher.State.BootFsType, config.BootDir, cfg.Rancher.State.BootMountOpt); err != nil {
 		log.Debugf("Not mounting BOOT: %v", err)
 	} else {
 		log.Infof("Mounted BOOT: %s", cfg.Rancher.State.BootDev)
@@ -54,32 +56,51 @@
 	return cfg, nil
 }
 
-func mountConfigured(display, dev, fsType, target string) error {
-	var err error
+func mountConfigured(display, dname, fsType, target, option string) error {
+
 
-	if dev == "" {
+	if dname == "" {
 		return nil
 	}
 
-	dev = util.ResolveDevice(dev)
-	if dev == "" {
-		return fmt.Errorf("Could not resolve device %q", dev)
-	}
-	if fsType == "auto" {
-		fsType, err = util.GetFsType(dev)
-	}
+	log.Infof("Mounting %s device %s to %s (option = '%s')", display, dname, target, option)
 
-	if err != nil {
-		return err
+	if _, err := os.Stat("/usr/bin/do_mount"); err == nil {
+		cmd := exec.Command("/usr/bin/do_mount", dname, target, "--initrd", "--verbose", "-o", option)
+		cmd.Stderr = os.Stderr
+		errb := cmd.Run()
+		if errb != nil {
+			log.Infof("exec /usr/bin/do_mount, failed!")
+			log.Infof("Mouting %s failed!", display)
+			return err
+		}
+		if _, err := os.Stat("/var/tmp/do_mount/degraded"); err == nil {
+			MountDegraded = true
+		}
+		return nil
+
+	} else {
+		log.Warn("'do_mount' is not found.")
+		dev := util.ResolveDevice(dname)
+		if dev == "" {
+			return fmt.Errorf("Could not resolve device %q", dev)
+		}
+		if fsType == "auto" {
+			fsType, err = util.GetFsType(dev)
+		}
+
+		if err != nil {
+			return err
+		}
+		log.Debugf("FsType has been set to %s", fsType)
+		log.Infof("Mounting %s device %s to %s", display, dev, target)
+		return util.Mount(dev, target, fsType, option)
 	}
 
-	log.Debugf("FsType has been set to %s", fsType)
-	log.Infof("Mounting %s device %s to %s", display, dev, target)
-	return util.Mount(dev, target, fsType, "")
 }
 
 func mountState(cfg *config.CloudConfig) error {
-	return mountConfigured("state", cfg.Rancher.State.Dev, cfg.Rancher.State.FsType, config.StateDir)
+	return mountConfigured("state", cfg.Rancher.State.Dev, cfg.Rancher.State.FsType, config.StateDir, cfg.Rancher.State.MountOpt)
 }
 
 func tryMountState(cfg *config.CloudConfig) error {
diff -Naur '--exclude=.git' os.prev/pkg/init/prepare/prepare.go os.new/pkg/init/prepare/prepare.go
--- os.prev/pkg/init/prepare/prepare.go	2024-03-14 20:29:45.967485300 +0900
+++ os.new/pkg/init/prepare/prepare.go	2024-05-23 06:49:29.197889400 +0900
@@ -3,6 +3,8 @@
 import (
 	"os"
 	"strings"
+	"os/exec"
+	"io"
 
 	"github.com/burmilla/os/config"
 	"github.com/burmilla/os/pkg/dfs"
@@ -24,18 +26,49 @@
 	return c, dfs.PrepareFs(&mountConfig)
 }
 
+func CopyFile(srcPath, dstPath string) error {
+    srcFile, err := os.Open(srcPath)
+    if err != nil {
+        return err
+    }
+    defer srcFile.Close()
+
+    dstFile, err := os.Create(dstPath)
+    if err != nil {
+        return err
+    }
+    defer dstFile.Close()
+
+    _, err = io.Copy(dstFile, srcFile)
+    if err != nil {
+        return err
+    }
+
+    return nil
+}
+
 func SaveCmdline(c *config.CloudConfig) (*config.CloudConfig, error) {
 	// the Kernel Patch added for BurmillaOS passes `--` (only) elided kernel boot params to the init process
 	cmdLineArgs := strings.Join(os.Args, " ")
 	config.SaveInitCmdline(cmdLineArgs)
 
 	cfg := config.LoadConfig()
+
+	cmd := exec.Command("/sbin/after_save_cmd_line")
+	cmd.Stderr = os.Stderr
+	_, errb := cmd.Output()
+	if errb != nil {
+		log.Infof("exec /sbin/after_save_cmd_line failed.")
+	}else{
+		log.Infof("executed /sbin/after_save_cmd_line")
+	}
+
 	log.Debugf("Cmdline debug = %t", cfg.Rancher.Debug)
 	if cfg.Rancher.Debug {
 		log.SetLevel(log.DebugLevel)
 	} else {
 		log.SetLevel(log.InfoLevel)
 	}
-
+	
 	return cfg, nil
 }
diff -Naur '--exclude=.git' os.prev/pkg/init/switchroot/switchroot.go os.new/pkg/init/switchroot/switchroot.go
--- os.prev/pkg/init/switchroot/switchroot.go	2024-03-14 20:29:45.967485300 +0900
+++ os.new/pkg/init/switchroot/switchroot.go	2024-05-19 07:33:18.680455000 +0900
@@ -4,9 +4,10 @@
 	"fmt"
 	"io/ioutil"
 	"os"
+	"os/exec"
 	"path"
-	"strings"
 	"syscall"
+	"strings"
 
 	"github.com/burmilla/os/config"
 	"github.com/burmilla/os/pkg/dfs"
@@ -51,12 +52,26 @@
 	return true, nil
 }
 
+func createSymLink(src string, target string) {
+	if err := os.Remove(target); err != nil {
+		log.Infof("%s does not exist", target)
+	}
+
+	if err := os.Symlink(src, target); err != nil{
+		log.Errorf("Cannot create symlink, %s -> %s", src, target)
+	}else{
+		log.Infof("Created symlink, %s -> %s", src, target)
+	}
+}
+
+
 func copyMoveRoot(rootfs string, rmUsr bool) error {
 	usrVer := fmt.Sprintf("usr-%s", config.Version)
 	usr := path.Join(rootfs, usrVer)
 	targetUsr := path.Join(rootfs, "usr")
 	tmpDir := path.Join(rootfs, "tmp")
 
+	
 	if rmUsr {
 		log.Warnf("Development setup. Removing old usr: %s", usr)
 		if err := os.RemoveAll(usr); err != nil {
@@ -109,6 +124,11 @@
 		}
 	}
 
+	createSymLink("usr/bin", path.Join(rootfs, "bin"))
+	createSymLink("usr/lib", path.Join(rootfs, "lib"))
+	createSymLink("lib", path.Join(rootfs, "lib64"))
+	createSymLink("usr/sbin", path.Join(rootfs, "sbin"))
+
 	return nil
 }
 
@@ -141,6 +161,7 @@
 		if err := syscall.Mount(i, path.Join(rootfs, i), "", syscall.MS_MOVE, ""); err != nil {
 			return err
 		}
+		os.Symlink(path.Join(rootfs, i), i)
 	}
 
 	if err := copyMoveRoot(rootfs, rmUsr); err != nil {
@@ -154,10 +175,19 @@
 
 	log.Debugf("mount MS_MOVE %s", rootfs)
 	if err := syscall.Mount(rootfs, "/", "", syscall.MS_MOVE, ""); err != nil {
-		return err
+		log.Warnf("MS_MOVE failed (%v).", err)
+		dmsg, errb := exec.Command("bash", "-c", "dmesg | tail -10").Output()
+		if errb == nil {
+			log.Warnf("%s", string(dmsg))
+		}
+		log.Warnf("Continue by chrooting.", err)
+		if errb != nil {
+			log.Warnf("cannot exec dmesg (Error:%v)", errb)
+		}
 	}
 
 	log.Debug("chroot .")
+
 	if err := syscall.Chroot("."); err != nil {
 		return err
 	}
diff -Naur '--exclude=.git' os.prev/pkg/log/log.go os.new/pkg/log/log.go
--- os.prev/pkg/log/log.go	2024-03-14 20:29:45.967485300 +0900
+++ os.new/pkg/log/log.go	2024-05-23 18:42:19.297889400 +0900
@@ -2,22 +2,50 @@
 
 import (
 	"fmt"
+	"time"
+  "strconv"
 	"io"
 	"log/syslog"
 	"os"
+	"os/exec"
+	"bytes"
+	"syscall"
 	"path/filepath"
 	"strings"
+	"encoding/json"
 
 	"github.com/burmilla/os/config/cmdline"
-
+	"github.com/google/shlex"
 	"github.com/sirupsen/logrus"
+
 	lsyslog "github.com/sirupsen/logrus/hooks/syslog"
+
+)
+
+const (
+	tmpfsMagic int64 = 0x01021994
+	ramfsMagic int64 = 0x858458f6
+	DefaultTimeFormat = "2006-01-02 Mon 15:04:05.000000 -0700"
+	oemVarDir = "/usr/share/ros/oem/var/lib/rancher"
+	oemVarDirInitrd = oemVarDir + "/initrd"
+	timeDiffFN = oemVarDirInitrd + "/time_diff_seconds"
+	tzFN = oemVarDirInitrd + "/TZ"
+	initrdInfoDir = "/opt/rancher/initrd"
+	timeDiffFN2 = initrdInfoDir + "/time_diff_seconds"
 )
 
 var logFile *os.File
 var userHook *ShowuserlogHook
 var defaultLogLevel logrus.Level
 var debugThisLogger = false
+var preservedLogs = ""
+var preserveLogFN = ""
+var doPreserve = false
+var base = -1 // time difference
+var tz = "" // time zone name
+var checkOemVarDir = false
+var initFormatExecuted = false
+var cline = ""
 
 type Fields logrus.Fields
 type Level logrus.Level
@@ -63,53 +91,145 @@
 	return Level(logrus.GetLevel())
 }
 
+
+func UntilLogWritable(lgFName string){
+	preserveLogFN = lgFName
+	fmt.Printf("setting log file, '%s'\n", preserveLogFN)
+}
+
+func mayRedirect(lv string, format string, args ...interface{}) {
+	msg := fmt.Sprintf(format, args...)
+	_mayRedirect(lv, msg)
+}
+
+func _mayRedirect(lv string, args ...interface{}) {
+	if preserveLogFN != "" {
+		t := time.Now()
+		_, err := os.Stat(preserveLogFN)
+		if err != nil { // file missing
+			doPreserve = true
+		} else { // file exists
+			if doPreserve {
+				 // write preserved
+				file, err := os.OpenFile(preserveLogFN, os.O_WRONLY|os.O_APPEND, 0644)
+				if err == nil {
+					file.WriteString(preservedLogs)
+					file.Close()
+				}
+				preserveLogFN = ""
+				doPreserve = false
+				if base != -1 {
+					checkOemVarDir = true
+				}
+			}
+		}
+		if doPreserve {
+			msg := ""
+			for _, arg := range args{
+				msg += fmt.Sprintf("%v", arg)
+			}
+			preservedLogs += strings.ToUpper(lv + " ")[0:5] + " " + t.Format(DefaultTimeFormat) + " " + msg + "\n"
+		}
+	}
+	if checkOemVarDir {
+		_, err := os.Stat(oemVarDir)
+		if err == nil {
+			checkOemVarDir = false
+			os.Mkdir(oemVarDirInitrd, 0755)
+			file, err := os.Create(timeDiffFN)
+			if err == nil {
+				file.WriteString(fmt.Sprintf("%d", base))
+				file.Close()
+				file, err = os.Create(tzFN)
+				if err == nil {
+					file.WriteString(tz)
+					file.Close()
+				}
+			}
+		}
+	}
+}
+
+
 func Debugf(format string, args ...interface{}) {
+	mayRedirect("DEBUG", format, args...)
+	initFormat()
 	logrus.Debugf(format, args...)
 }
 func Infof(format string, args ...interface{}) {
+	mayRedirect("INFO ", format, args...)
+	initFormat()
 	logrus.Infof(format, args...)
 }
 func Printf(format string, args ...interface{}) {
+	mayRedirect("PRINT", format, args...)
+	initFormat()
 	logrus.Printf(format, args...)
 }
 func Warnf(format string, args ...interface{}) {
+	mayRedirect("WARN ", format, args...)
+	initFormat()
 	logrus.Warnf(format, args...)
 }
 func Warningf(format string, args ...interface{}) {
+	mayRedirect("WARN ", format, args...)
+	initFormat()
 	logrus.Warningf(format, args...)
 }
 func Errorf(format string, args ...interface{}) {
+	mayRedirect("ERROR", format, args...)
+	initFormat()
 	logrus.Errorf(format, args...)
 }
 func Fatalf(format string, args ...interface{}) {
+	mayRedirect("FATAL", format, args...)
+	initFormat()
 	logrus.Fatalf(format, args...)
 }
 func Panicf(format string, args ...interface{}) {
+	mayRedirect("PANIC", format, args...)
+	initFormat()
 	logrus.Panicf(format, args...)
 }
 
 func Debug(args ...interface{}) {
+	_mayRedirect("DEBUG", args...)
+	initFormat()
 	logrus.Debug(args...)
 }
 func Info(args ...interface{}) {
+	_mayRedirect("INFO ", args...)
+	initFormat()
 	logrus.Info(args...)
 }
 func Print(args ...interface{}) {
+	_mayRedirect("PRINT", args...)
+	initFormat()
 	logrus.Print(args...)
 }
 func Warn(args ...interface{}) {
+	_mayRedirect("DEBUG", args...)
+	initFormat()
 	logrus.Warn(args...)
 }
 func Warning(args ...interface{}) {
+	_mayRedirect("WARN ", args...)
+	initFormat()
 	logrus.Warning(args...)
 }
 func Error(args ...interface{}) {
+	_mayRedirect("ERROR", args...)
+	initFormat()
 	logrus.Error(args...)
 }
 func Fatal(args ...interface{}) {
+	_mayRedirect("FATAL", args...)
+	initFormat()
 	logrus.Fatal(args...)
 }
 func Panic(args ...interface{}) {
+	_mayRedirect("PANIC", args...)
+	initFormat()
 	logrus.Panic(args...)
 }
 
@@ -120,8 +240,245 @@
 	return logrus.WithFields(logrus.Fields(fields))
 }
 
+
+func isInitrd() bool {
+	var stat syscall.Statfs_t
+	syscall.Statfs("/", &stat)
+	return int64(stat.Type) == tmpfsMagic || int64(stat.Type) == ramfsMagic
+}
+
+
+type logFormat struct {
+    TimestampFormat string
+}
+
+//Format function
+func (f *logFormat) Format(entry *logrus.Entry) ([]byte, error) {
+    var b *bytes.Buffer
+
+    if entry.Buffer != nil {
+        b = entry.Buffer
+    } else {
+        b = &bytes.Buffer{}
+    }
+
+    b.WriteString(strings.ToUpper(entry.Level.String() + " ")[0:5])
+    b.WriteString(" ")
+    b.WriteString(entry.Time.Format(f.TimestampFormat))
+
+    if entry.Message != "" {
+        b.WriteString(" ")
+        b.WriteString(entry.Message)
+    }
+
+    if len(entry.Data) > 0 {
+        b.WriteString(" || ")
+    }
+    for key, value := range entry.Data {
+        b.WriteString(key)
+        b.WriteByte('=')
+        b.WriteByte('{')
+        fmt.Fprint(b, value)
+        b.WriteString("}, ")
+    }
+
+    b.WriteByte('\n')
+    return b.Bytes(), nil
+}
+
+
+type jFormat struct {
+}
+
+func (f *jFormat) Format(entry *logrus.Entry) ([]byte, error) {
+  serialized, err := json.Marshal(entry.Data)
+    if err != nil {
+      return nil, fmt.Errorf("Failed to marshal fields to JSON, %v", err)
+    }
+  return append(serialized, '\n'), nil
+}
+
+
+
+func ReadInt(filename string) (int, error) {
+	file, err := os.Open(filename)
+	if err != nil {
+		return -1, err
+	}
+	defer file.Close()
+
+	var buffer bytes.Buffer
+	_, err = io.Copy(&buffer, file)
+	if err != nil {
+		return -1, err
+	}
+	b, _ := strconv.Atoi(buffer.String())
+	return b, nil
+}
+
+func ReadAll(filename string) (string, error) {
+	file, err := os.Open(filename)
+	if err != nil {
+		return "", err
+	}
+	defer file.Close()
+
+	var buffer bytes.Buffer
+	_, err = io.Copy(&buffer, file)
+	if err != nil {
+		return "", err
+	}
+
+	return buffer.String(), nil
+}
+
+
+func getParam(name string) string {
+	Infof("getParam %s", name)
+	res := os.Getenv(name)
+	var err error
+	if res == "" {
+		Infof("res = ''")
+		if cline == "" {
+			Infof("Trying read /proc/cmdline")
+			cline, err = ReadAll("/proc/cmdline")
+			if err != nil {
+				Infof("Error %v", err)
+			}
+		}
+		if cline != "" {
+			Infof("/proc/cmdline = %s", cline)
+			words, err := shlex.Split(cline)
+			if err != nil {
+				Infof("cannot parse /proc/cmdline")
+			}else{
+				found := false
+				for _, word := range words {
+					if strings.HasPrefix(word, name + "=") {
+						res = word[len(name) + 1:]
+						Infof("found %s", res)
+						found = true
+					}
+				}
+				if !found {
+					Infof("cannot find '%s=' in /proc/cmdline", name)
+				}
+			}
+		}else{
+			Infof("cannot read /proc/cmdline")
+		}
+	}
+	return res
+}
+
+
+func getBase(tz string) error {
+	Infof("getBase %s", tz)
+	out, errb := exec.Command("bash", "-c", "TZ=" + tz + " date +%z").Output()
+	if errb != nil {
+		out, errb = exec.Command("bash", "-c", "TZ=" + tz + " /usr/bin/date +%z").Output()
+		if errb != nil {
+			out, errb = exec.Command("bash", "-c", "TZ=" + tz + " /bin/date +%z").Output()
+		}
+	}
+	if errb == nil {
+		td := strings.TrimSpace(string(out))
+		Infof("output of 'date %%z': %s", td)
+		a, _ := strconv.Atoi(td[1:3])
+		b, _ := strconv.Atoi(td[3:])
+		base = a * 60 * 60 + b * 60
+		if td[0:1] == "-" {
+			base = -base
+		}
+		Infof("base = %i", base)
+	}
+	return errb
+}
+
+// InitLogger sets up Logging to log to /dev/kmsg and to Syslog
+func initFormat() {
+	if !initFormatExecuted {
+		base = -1
+		initFormatExecuted = true
+		formatter := logFormat{}
+		formatter.TimestampFormat = DefaultTimeFormat
+		if getParam("ROS_LOG_FORMAT") == "non-json" {
+			logrus.SetFormatter(&formatter)
+		}else{
+			formatter := &logrus.JSONFormatter{
+				FieldMap: logrus.FieldMap{
+					logrus.FieldKeyTime:  "@timestamp",
+				 	logrus.FieldKeyLevel: "@level",
+					logrus.FieldKeyMsg:   "@message",
+				},
+			}
+			logrus.SetFormatter(formatter)
+		}
+		nullSymlinked := false
+		Infof("before set: base = %d", base)
+		if base == -1 {
+			_, err := os.Stat("/dev/null")
+			if err != nil { // file missing
+				_, err := os.Stat("/idev/null")
+				if err == nil {
+					os.Symlink("/idev/null", "/dev/null")
+					nullSymlinked = true // initrd started
+				}
+			} else {
+				base, _ = ReadInt(timeDiffFN)
+				Infof("ReadInt(timeDiffFN): base = %d", base)
+				str, err := ReadAll(tzFN)
+				if err == nil { // file exists
+					tz = strings.TrimSpace(str)
+				}
+			}
+			Infof("Now base = $d", base)
+			if err != nil || base == -1 {
+				tz = os.Getenv("TZ")
+				if tz == "" {
+					targetPath, err := os.Readlink("/etc/localtime")
+					if err == nil {
+						tz = strings.TrimPrefix(targetPath, "/usr/share/zoneinfo/")
+					}
+				}
+				if tz != "" {
+					if errb := getBase(tz); errb != nil {
+						if(nullSymlinked){
+							Infof("exec 'date', failed: %v", errb)
+						}
+					}
+				}
+			}
+		}
+		if base == -1 {
+			if errb := getBase(tz); errb != nil{
+				if(nullSymlinked){
+					Infof("exec 'date', failed: %v", errb)
+				}
+			}
+		}
+		if base != -1 {
+			if tz == "" {
+				tz = "LOCAL"
+			}
+			loc := time.FixedZone(tz, base)
+			time.Local = loc
+			Infof("set time zone")
+			Infof("time difference: %d seconds", base)
+		}
+		if nullSymlinked {
+			os.Remove("/dev/null")
+		}
+		if isInitrd() {
+			Infof("logger started in initrd.")
+		}
+		Infof("after set: base = %d", base)
+	}
+}
+
 // InitLogger sets up Logging to log to /dev/kmsg and to Syslog
 func InitLogger() {
+	initFormat()
 	if logTheseApps() {
 		innerInit(false)
 		FsReady()
@@ -131,6 +488,8 @@
 		if err != nil {
 			logrus.Error(err)
 		}
+    	logrus.SetReportCaller(true)
+    	initFormat()
 		logrus.Debugf("START: %v in %s", os.Args, pwd)
 	}
 }
@@ -163,6 +522,7 @@
 		if err != nil {
 			logrus.Error(err)
 		}
+    	initFormat()
 		logrus.Debugf("START: %v in %s", os.Args, pwd)
 	}
 }
@@ -181,7 +541,7 @@
 }
 
 // AddRSyslogHook only needs to be called separately when using the InitDeferedLogger
-// init.Main can't read /proc/cmdline at start.
+// init.Main can't read /proc/cline at start.
 // and then fails due to the network not being up
 // TODO: create a "defered SyslogHook that always gets initialised, but if it fails to connect, stores the logs
 //
@@ -249,8 +609,10 @@
 
 	if debugThisLogger {
 		if deferedHook {
+			initFormat()
 			logrus.Debugf("------------info Starting defered User Hook (%s)", os.Args[0])
 		} else {
+			initFormat()
 			logrus.Debugf("------------info Starting User Hook (%s)", os.Args[0])
 		}
 	}
diff -Naur '--exclude=.git' os.prev/pkg/sysinit/sysinit.go os.new/pkg/sysinit/sysinit.go
--- os.prev/pkg/sysinit/sysinit.go	2024-03-14 20:29:45.967485300 +0900
+++ os.new/pkg/sysinit/sysinit.go	2024-05-14 20:04:27.427314900 +0900
@@ -93,6 +93,14 @@
 }
 
 func SysInit() error {
+	log.Infof("executing /sbin/before_sysinit")
+	cmd := exec.Command("/sbin/before_sysinit")
+	cmd.Stderr = os.Stderr
+	_, errb := cmd.Output()
+	if errb != nil {
+		log.Infof("exec /sbin/before_sysinit failed.")
+	}
+
 	cfg := config.LoadConfig()
 
 	if err := control.PreloadImages(docker.NewSystemClient, systemImagesPreloadDirectory); err != nil {
diff -Naur '--exclude=.git' os.prev/scripts/package-installer os.new/scripts/package-installer
--- os.prev/scripts/package-installer	2024-03-14 20:29:45.977485300 +0900
+++ os.new/scripts/package-installer	2024-05-14 20:04:27.427314900 +0900
@@ -38,13 +38,14 @@
 
 # installer base image - can be included in iso
 # TODO: fix the fullinstaller Dockerfile to use the ${VERSION}${SUFFIX}
+# modified to include fullistaller.tar by Yougain: 20240318
 docker build \
     -t ${OS_REPO}/os-installer \
     --build-arg VERSION=${VERSION} \
     --build-arg KERNEL_VERSION=${KERNEL_VERSION} \
     -f $BASEDOCKERFILE \
     ./scripts/installer
-docker save -o ${ARTIFACTS}/installer.tar ${OS_REPO}/os-installer
+docker save -o ${ARTIFACTS}/fullinstaller.tar ${OS_REPO}/os-installer
 cp $DOCKERFILE ${ARTIFACTS}/
 
 cp ${ARTIFACTS}/${INITRD} ./scripts/installer/build/boot
diff -Naur '--exclude=.git' os.prev/scripts/package-iso os.new/scripts/package-iso
--- os.prev/scripts/package-iso	2024-03-14 20:29:45.977485300 +0900
+++ os.new/scripts/package-iso	2024-05-14 20:04:27.427314900 +0900
@@ -29,9 +29,9 @@
 cp /usr/lib/syslinux/modules/bios/ldlinux.c32  ${CD}/boot/isolinux/
 cp /usr/lib/syslinux/modules/bios/*.c32        ${CD}/boot/isolinux/
 # add the installer image to the iso for non-network / dev/test
-cp ${ARTIFACTS}/installer.tar                  ${CD}/rancheros/
+cp ${ARTIFACTS}/fullinstaller.tar                  ${CD}/rancheros/
 cp ${ARTIFACTS}/Dockerfile.${ARCH}             ${CD}/rancheros/
-gzip ${CD}/rancheros/installer.tar
+gzip ${CD}/rancheros/fullinstaller.tar
 cd ${CD} && xorriso \
     -as mkisofs \
     -l -J -R -V "${DISTRIB_ID}" \
diff -Naur '--exclude=.git' os.prev/scripts/version os.new/scripts/version
--- os.prev/scripts/version	2024-03-14 20:29:45.977485300 +0900
+++ os.new/scripts/version	2024-05-14 20:04:27.427314900 +0900
@@ -1,18 +1,27 @@
 #!/bin/bash
 
-if [ -n "$(git status --porcelain --untracked-files=no)" ]; then
-    DIRTY="-dirty"
-fi
+#if [ -n "$(git status --porcelain --untracked-files=no)" ]; then
+#    DIRTY="-dirty"
+#fi
 
 COMMIT=$(git rev-parse --short HEAD)
 GIT_TAG=$(git tag -l --contains HEAD | head -n 1)
 
-if [ -z "$VERSION" ]; then
-    if [[ -z "$DIRTY" && -n "$GIT_TAG" ]]; then
-        VERSION=$GIT_TAG
-    else
-        VERSION="${COMMIT}${DIRTY}"
-    fi
+#if [ -z "$VERSION" ]; then
+#    if [[ -z "$DIRTY" && -n "$GIT_TAG" ]]; then
+#        VERSION=$GIT_TAG-btrfs-0.9
+#    else
+#        VERSION="${COMMIT}${DIRTY}"
+#    fi
+#fi
+
+if [ ! -e ../.git/packed-refs ]; then
+	VERSION=`cat /tmp/version.patched`
+else
+	#TTAG=`tail -1 ../.git/packed-refs`
+	#VERSION=${TTAG##*/}-btrfs-__PVER__
+	VERSION=${GIT_TAG}-btrfs-__PVER__
+	echo -n $VERSION > /tmp/version.patched
 fi
 
 INITRD=initrd-${VERSION}
